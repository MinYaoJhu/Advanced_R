---
title: "Ch13_S3-2"
author: "Min-Yao"
date: "2023-03-05"
output: 
  html_document: 
    keep_md: yes
---


```r
library(sloop)
library(tidyverse)
```

```
## â”€â”€ Attaching core tidyverse packages â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ tidyverse 2.0.0 â”€â”€
## âœ” dplyr     1.1.0     âœ” readr     2.1.4
## âœ” forcats   1.0.0     âœ” stringr   1.5.0
## âœ” ggplot2   3.4.1     âœ” tibble    3.2.0
## âœ” lubridate 1.9.2     âœ” tidyr     1.3.0
## âœ” purrr     1.0.1     
## â”€â”€ Conflicts â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ tidyverse_conflicts() â”€â”€
## âœ– dplyr::filter() masks stats::filter()
## âœ– dplyr::lag()    masks stats::lag()
## â„¹ Use the ]8;;http://conflicted.r-lib.org/conflicted package]8;; to force all conflicts to become errors
```

```r
library(purrr)
library(pryr)
```

```
## 
## Attaching package: 'pryr'
## 
## The following object is masked from 'package:dplyr':
## 
##     where
## 
## The following objects are masked from 'package:purrr':
## 
##     compose, partial
## 
## The following objects are masked from 'package:sloop':
## 
##     ftype, is_s3_generic, is_s3_method, otype
```


## 13.4 Generics and methods {#s3-methods}
\indexc{UseMethod()} 
\index{S3!generics}
\index{generics!S3}

The job of an S3 generic is to perform method dispatch, i.e. find the specific implementation for a class. Method dispatch is performed by `UseMethod()`, which every generic calls[^internal-generic]. `UseMethod()` takes two arguments: the name of the generic function (required), and the argument to use for method dispatch (optional). If you omit the second argument, it will dispatch based on the first argument, which is almost always what is desired.

[^internal-generic]: The exception is internal generics, which are implemented in C, and are the topic of Section \@ref(internal-generics).

Most generics are very simple, and consist of only a call to `UseMethod()`. Take `mean()` for example:


```r
mean
```

```
## function (x, ...) 
## UseMethod("mean")
## <bytecode: 0x0000025a01a5d550>
## <environment: namespace:base>
```

Creating your own generic is similarly simple:


```r
my_new_generic <- function(x) {
  UseMethod("my_new_generic")
}
```

(If you wonder why we have to repeat `my_new_generic` twice, think back to Section \@ref(first-class-functions).)

You don't pass any of the arguments of the generic to `UseMethod()`; it uses deep magic to pass to the method automatically. The precise process is complicated and frequently surprising, so you should avoid doing any computation in a generic. To learn the full details, carefully read the Technical Details section in `?UseMethod`.

### 13.4.1 Method dispatch
\index{S3!method dispatch}
\index{method dispatch!S3}

How does `UseMethod()` work? It basically creates a vector of method names, `paste0("generic", ".", c(class(x), "default"))`, and then looks for each potential method in turn. We can see this in action with `sloop::s3_dispatch()`. You give it a call to an S3 generic, and it lists all the possible methods. For example, what method is called when you print a `Date` object?


```r
x <- Sys.Date()
s3_dispatch(print(x))
```

```
## => print.Date
##  * print.default
```

The output here is simple:

* `=>` indicates the method that is called, here `print.Date()`
* `*` indicates a method that is defined, but not called, here `print.default()`.

The "default" class is a special __pseudo-class__. This is not a real class, but is included to make it possible to define a standard fallback that is found whenever a class-specific method is not available.

The essence of method dispatch is quite simple, but as the chapter proceeds you'll see it get progressively more complicated to encompass inheritance, base types, internal generics, and group generics. The code below shows a couple of more complicated cases which we'll come back to in Sections \@ref(inheritance) and \@ref(s3-dispatch). 


```r
x <- matrix(1:10, nrow = 2)
s3_dispatch(mean(x))
```

```
##    mean.matrix
##    mean.integer
##    mean.numeric
## => mean.default
```

```r
s3_dispatch(sum(Sys.time()))
```

```
##    sum.POSIXct
##    sum.POSIXt
##    sum.default
## => Summary.POSIXct
##    Summary.POSIXt
##    Summary.default
## -> sum (internal)
```

> s3_dispatch() prints a list of all possible function names that will be considered for method dispatch. There are four possible states:

=> method exists and is found by UseMethod().

-> method exists and is used by NextMethod().

* method exists but is not used.

Nothing (and greyed out in console): method does not exist.

### 13.4.2 Finding methods
\index{S3!methods!locating}

`sloop::s3_dispatch()` lets you find the specific method used for a single call. What if you want to find all methods defined for a generic or associated with a class? That's the job of `sloop::s3_methods_generic()` and `sloop::s3_methods_class()`:


```r
s3_methods_generic("mean")
```

```
## # A tibble: 7 Ã— 4
##   generic class      visible source             
##   <chr>   <chr>      <lgl>   <chr>              
## 1 mean    Date       TRUE    base               
## 2 mean    default    TRUE    base               
## 3 mean    difftime   TRUE    base               
## 4 mean    POSIXct    TRUE    base               
## 5 mean    POSIXlt    TRUE    base               
## 6 mean    quosure    FALSE   registered S3method
## 7 mean    vctrs_vctr FALSE   registered S3method
```

```r
s3_methods_class("ordered")
```

```
## # A tibble: 6 Ã— 4
##   generic       class   visible source             
##   <chr>         <chr>   <lgl>   <chr>              
## 1 as.data.frame ordered TRUE    base               
## 2 Ops           ordered TRUE    base               
## 3 relevel       ordered FALSE   registered S3method
## 4 scale_type    ordered FALSE   registered S3method
## 5 Summary       ordered TRUE    base               
## 6 type_sum      ordered FALSE   registered S3method
```

### 13.4.3 Creating methods {#s3-arguments}
\index{S3!methods!creating}
\index{methods!S3}

There are two wrinkles to be aware of when you create a new method:

*   First, you should only ever write a method if you own the generic or the
    class. R will allow you to define a method even if you don't, but it is
    exceedingly bad manners. Instead, work with the author of either the 
    generic or the class to add the method in their code.

*   A method must have the same arguments as its generic. This is enforced in
    packages by `R CMD check`, but it's good practice even if you're not 
    creating a package. 

    There is one exception to this rule: if the generic has `...`, the method 
    can contain a superset of the arguments. This allows methods to take 
    arbitrary additional arguments. The downside of using `...`, however, is 
    that any misspelled arguments will be silently swallowed[^ellipsis],
    as mentioned in Section \@ref(fun-dot-dot-dot).

[^ellipsis]: See <https://github.com/hadley/ellipsis> for an experimental way of warning when methods fail to use all the arguments in `...`, providing a potential resolution of this issue.

### 13.4.4 Exercises

1.  Read the source code for `t()` and `t.test()` and confirm that
    `t.test()` is an S3 generic and not an S3 method. What happens if
    you create an object with class `test` and call `t()` with it? Why?

    
    ```r
    x <- structure(1:10, class = "test")
    t(x)
    ```


```r
t
```

```
## function (x) 
## UseMethod("t")
## <bytecode: 0x0000025a04620f98>
## <environment: namespace:base>
```


```r
t.test
```

```
## function (x, ...) 
## UseMethod("t.test")
## <bytecode: 0x0000025a00f76658>
## <environment: namespace:stats>
```


```r
s3_methods_generic("t.test")
```

```
## # A tibble: 2 Ã— 4
##   generic class   visible source             
##   <chr>   <chr>   <lgl>   <chr>              
## 1 t.test  default FALSE   registered S3method
## 2 t.test  formula FALSE   registered S3method
```


```r
s3_methods_class("t.test")
```

```
## # A tibble: 0 Ã— 4
## # â€¦ with 4 variables: generic <chr>, class <chr>, visible <lgl>, source <chr>
```


```r
s3_dispatch(t.test(1:10, y = c(7:20)))
```

```
##    t.test.integer
##    t.test.numeric
## => t.test.default
```


```r
ftype(t.test)
```

```
## [1] "s3"      "generic"
```


```r
s3_dispatch(t(x))
```

```
## => t.test
##  * t.default
```



```r
tools::nonS3methods("stats")
```

```
## [1] "anova.lmlist"        "expand.model.frame"  "fitted.values"      
## [4] "influence.measures"  "lag.plot"            "t.test"             
## [7] "plot.spec.phase"     "plot.spec.coherency"
```


> `t.test()` is an S3 generic and not an S3 method.

> When we create an object with class test, t() dispatches to the t.default() method. This happens, because UseMethod() simply searches for functions named paste0("generic", ".", c(class(x), "default")).


```r
x <- structure(1:10, class = "test")

t(x)
```

```
##      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]
## [1,]    1    2    3    4    5    6    7    8    9    10
## attr(,"class")
## [1] "test"
```


2.  What generics does the `table` class have methods for?


```r
s3_methods_class("table")
```

```
## # A tibble: 11 Ã— 4
##    generic       class visible source             
##    <chr>         <chr> <lgl>   <chr>              
##  1 [             table TRUE    base               
##  2 aperm         table TRUE    base               
##  3 as.data.frame table TRUE    base               
##  4 as_tibble     table FALSE   registered S3method
##  5 Axis          table FALSE   registered S3method
##  6 lines         table FALSE   registered S3method
##  7 plot          table FALSE   registered S3method
##  8 points        table FALSE   registered S3method
##  9 print         table TRUE    base               
## 10 summary       table TRUE    base               
## 11 tail          table FALSE   registered S3method
```


3.  What generics does the `ecdf` class have methods for?


```r
s3_methods_class("ecdf")
```

```
## # A tibble: 4 Ã— 4
##   generic  class visible source             
##   <chr>    <chr> <lgl>   <chr>              
## 1 plot     ecdf  TRUE    stats              
## 2 print    ecdf  FALSE   registered S3method
## 3 quantile ecdf  FALSE   registered S3method
## 4 summary  ecdf  FALSE   registered S3method
```


4.  Which base generic has the greatest number of defined methods?


```r
nrow(s3_methods_generic("plot"))
```

```
## [1] 34
```

```r
nrow(s3_methods_generic("print"))
```

```
## [1] 314
```

```r
nrow(s3_methods_generic("quantile"))
```

```
## [1] 5
```

```r
nrow(s3_methods_generic("summary"))
```

```
## [1] 44
```


```r
base_function <- ls(all.names = TRUE, env = baseenv()) %>% 
  mget(envir = baseenv()) %>% 
  keep(is_function) %>% 
  names()

str(base_function)
```

```
##  chr [1:1335] "-" "-.Date" "-.POSIXt" "!" "!.hexmode" "!.octmode" "!=" "$" ...
```

```r
s3_generic <- base_function %>% 
  keep(is_s3_generic)

str(s3_generic)
```

```
##  chr [1:172] "-" "!=" "$" "$<-" "%%" "%/%" "&" "*" "/" "[" "[[" "[[<-" ...
```


```r
n_meth_s3_generic <- s3_generic %>% 
  map(~ set_names(nrow(s3_methods_generic(.x)), .x)) %>% 
  flatten_dfr() 

n_meth_s3_generic
```

```
## # A tibble: 1 Ã— 172
##     `-`  `!=`   `$` `$<-`  `%%` `%/%`   `&`   `*`   `/`   `[`  `[[` `[[<-` `[<-`
##   <int> <int> <int> <int> <int> <int> <int> <int> <int> <int> <int>  <int> <int>
## 1     4     3    17    14     1     1     3     2     2    60    25     16    21
## # â€¦ with 159 more variables: `^` <int>, `|` <int>, `+` <int>, `<` <int>,
## #   `<=` <int>, `==` <int>, `>` <int>, `>=` <int>, abs <int>, acos <int>,
## #   acosh <int>, all <int>, all.equal <int>, any <int>, anyDuplicated <int>,
## #   anyNA <int>, aperm <int>, Arg <int>, as.array <int>, as.call <int>,
## #   as.character <int>, as.complex <int>, as.data.frame <int>, as.Date <int>,
## #   as.double <int>, as.environment <int>, as.expression <int>,
## #   as.function <int>, as.integer <int>, as.list <int>, as.logical <int>, â€¦
```

```r
str(n_meth_s3_generic)
```

```
## tibble [1 Ã— 172] (S3: tbl_df/tbl/data.frame)
##  $ -                       : int 4
##  $ !=                      : int 3
##  $ $                       : int 17
##  $ $<-                     : int 14
##  $ %%                      : int 1
##  $ %/%                     : int 1
##  $ &                       : int 3
##  $ *                       : int 2
##  $ /                       : int 2
##  $ [                       : int 60
##  $ [[                      : int 25
##  $ [[<-                    : int 16
##  $ [<-                     : int 21
##  $ ^                       : int 1
##  $ |                       : int 3
##  $ +                       : int 5
##  $ <                       : int 3
##  $ <=                      : int 3
##  $ ==                      : int 3
##  $ >                       : int 3
##  $ >=                      : int 3
##  $ abs                     : int 0
##  $ acos                    : int 0
##  $ acosh                   : int 0
##  $ all                     : int 0
##  $ all.equal               : int 12
##  $ any                     : int 0
##  $ anyDuplicated           : int 6
##  $ anyNA                   : int 5
##  $ aperm                   : int 2
##  $ Arg                     : int 0
##  $ as.array                : int 1
##  $ as.call                 : int 0
##  $ as.character            : int 41
##  $ as.complex              : int 0
##  $ as.data.frame           : int 33
##  $ as.Date                 : int 8
##  $ as.double               : int 6
##  $ as.environment          : int 1
##  $ as.expression           : int 1
##  $ as.function             : int 1
##  $ as.integer              : int 2
##  $ as.list                 : int 17
##  $ as.logical              : int 3
##  $ as.matrix               : int 8
##  $ as.null                 : int 1
##  $ as.numeric              : int 0
##  $ as.POSIXct              : int 12
##  $ as.POSIXlt              : int 14
##  $ as.raw                  : int 0
##  $ as.single               : int 1
##  $ as.table                : int 2
##  $ as.vector               : int 5
##  $ asin                    : int 0
##  $ asinh                   : int 0
##  $ atan                    : int 0
##  $ atanh                   : int 0
##  $ by                      : int 2
##  $ c                       : int 19
##  $ cbind                   : int 4
##  $ ceiling                 : int 0
##  $ chol                    : int 1
##  $ close                   : int 5
##  $ conditionCall           : int 1
##  $ conditionMessage        : int 5
##  $ Conj                    : int 0
##  $ cos                     : int 0
##  $ cosh                    : int 0
##  $ cospi                   : int 0
##  $ cummax                  : int 0
##  $ cummin                  : int 0
##  $ cumprod                 : int 0
##  $ cumsum                  : int 0
##  $ cut                     : int 4
##  $ determinant             : int 1
##  $ diff                    : int 6
##  $ digamma                 : int 0
##  $ dim                     : int 3
##  $ dim<-                   : int 2
##  $ dimnames                : int 3
##  $ dimnames<-              : int 4
##  $ droplevels              : int 2
##  $ duplicated              : int 9
##  $ exp                     : int 0
##  $ expm1                   : int 0
##  $ floor                   : int 0
##  $ flush                   : int 1
##  $ format                  : int 138
##  $ gamma                   : int 0
##  $ getDLLRegisteredRoutines: int 2
##  $ Im                      : int 0
##  $ is.array                : int 0
##  $ is.finite               : int 1
##  $ is.infinite             : int 1
##  $ is.matrix               : int 0
##  $ is.na                   : int 5
##  $ is.na<-                 : int 5
##  $ is.nan                  : int 1
##  $ is.numeric              : int 3
##   [list output truncated]
```



```r
long_n_meth_s3_generic <- n_meth_s3_generic %>% 
  pivot_longer(
    everything(), 
    names_to = "generic_name", 
    values_to = "n_methods")

long_n_meth_s3_generic
```

```
## # A tibble: 172 Ã— 2
##    generic_name n_methods
##    <chr>            <int>
##  1 -                    4
##  2 !=                   3
##  3 $                   17
##  4 $<-                 14
##  5 %%                   1
##  6 %/%                  1
##  7 &                    3
##  8 *                    2
##  9 /                    2
## 10 [                   60
## # â€¦ with 162 more rows
```



```r
long_n_meth_s3_generic %>% 
  arrange(desc(n_methods)) %>% 
  head()
```

```
## # A tibble: 6 Ã— 2
##   generic_name n_methods
##   <chr>            <int>
## 1 print              314
## 2 format             138
## 3 [                   60
## 4 summary             44
## 5 as.character        41
## 6 plot                34
```



```r
long_n_meth_s3_generic %>% 
  filter(n_methods == max(n_methods))
```

```
## # A tibble: 1 Ã— 2
##   generic_name n_methods
##   <chr>            <int>
## 1 print              314
```


5.  Carefully read the documentation for `UseMethod()` and explain why the
    following code returns the results that it does. What two usual rules
    of function evaluation does `UseMethod()` violate?


```r
g <- function(x,y) {
  x <- 10
  y <- 10
  UseMethod("g",y)
}
g.default <- function(x,y) c(x = x, y = y)
g.factor <- function(x,y) cat("factor")

x <- 1
y <- 1
g(x, factor(c("a","b")))
```

```
##  x y1 y2 
##  1  1  2
```

```r
s3_dispatch(g(x, factor(c("a","b"))))
```

```
##    g.double
##    g.numeric
## => g.default
```


```r
g <- function(x) {
  x <- 10
  y <- 10
  UseMethod("g")
}
g.default <- function(x) c(x = x, y = y)

x <- 1
y <- 1
g(x)
```

```
##  x  y 
##  1 10
```

```r
s3_dispatch(g(x))
```

```
##    g.double
##    g.numeric
## => g.default
```


```r
g <- function(x) {
  x <- 10
  y <- 10
  g2(x)
}

g2 <- function(x) c(x = x, y = y)

x <- 1
y <- 1
g(x)
```

```
##  x  y 
## 10  1
```

```r
g2(x)
```

```
## x y 
## 1 1
```


```r
g.default(x)
```

```
## x y 
## 1 1
```
> because UseMethod() calls g.default() in a special way so that variables defined inside the generic are available to methods. 

> The exception are arguments supplied to the function: they are passed on as is and cannot be affected by code inside the generic.

`UseMethod()`

> R possesses a simple generic function mechanism which can be used for an object-oriented style of programming. Method dispatch takes place based on the class(es) of the first argument to the generic function or of the object supplied as an argument to UseMethod or NextMethod.

> UseMethod(generic, object)

> An R object is a data object which has a class attribute (and this can be tested by is.object). A class attribute is a character vector giving the names of the classes from which the object inherits. If the object does not have a class attribute, it has an implicit class. Matrices and arrays have class "matrix" or"array" followed by the class of the underlying vector. Most vectors have class the result of mode(x), except that integer vectors have class c("integer", "numeric") and real vectors have class c("double", "numeric").

> When a function calling UseMethod("fun") is applied to an object with class attribute c("first", "second"), the system searches for a function called fun.first and, if it finds it, applies it to the object. If no such function is found a function called fun.second is tried. If no class name produces a suitable function, the function fun.default is used, if it exists, or an error results.

> UseMethod is a primitive function but uses standard argument matching. It is not the only means of dispatch of methods, for there are internal generic and group generic functions. UseMethod currently dispatches on the implicit class even for arguments that are not objects, but the other means of dispatch do not.


```r
g <- function(x) {
  x <- 10
  y <- 10
  UseMethod("g")
}

g.factor <- function(x) cat("FACTOR\n")
g.integer <- function(x) cat("INTEGER\n")
g.default <- function(x) cat("NOT THOSE\n")
x <- factor("A")
x2 <- 1L

g(x)
```

```
## FACTOR
```

```r
g(x2)
```

```
## INTEGER
```

```r
g(list())
```

```
## NOT THOSE
```

```r
g(c())
```

```
## NOT THOSE
```

```r
g.default(x)
```

```
## NOT THOSE
```

6.  What are the arguments to `[`? Why is this a hard question to answer?


```r
ftype(`[`)
```

```
## [1] "primitive" "generic"
```


```r
pryr::show_c_source(.Primitive("["))
```

```
## [ is implemented by do_subset with op = 1
```

```
## Please visit https://github.com/search?q=SEXP%20attribute_hidden%20do_subset+repo:wch/r-source&type=Code
```


```r
s3_methods_generic("[")
```

```
## # A tibble: 60 Ã— 4
##    generic class                 visible source             
##    <chr>   <chr>                 <lgl>   <chr>              
##  1 [       acf                   FALSE   registered S3method
##  2 [       arrow                 FALSE   registered S3method
##  3 [       AsIs                  TRUE    base               
##  4 [       bibentry              FALSE   registered S3method
##  5 [       check_details_changes FALSE   registered S3method
##  6 [       cli_doc               FALSE   registered S3method
##  7 [       data.frame            TRUE    base               
##  8 [       Date                  TRUE    base               
##  9 [       difftime              TRUE    base               
## 10 [       Dlist                 TRUE    base               
## # â€¦ with 50 more rows
```


```r
names(formals(`[.Date`))
```

```
## [1] "x"    "..."  "drop"
```

```r
names(formals(`[.data.frame`))
```

```
## [1] "x"    "i"    "j"    "drop"
```

> the arguments vary with the class of x.


```r
visible <- s3_methods_generic("[") %>%
  filter(visible)
visible
```

```
## # A tibble: 17 Ã— 4
##    generic class           visible source
##    <chr>   <chr>           <lgl>   <chr> 
##  1 [       AsIs            TRUE    base  
##  2 [       data.frame      TRUE    base  
##  3 [       Date            TRUE    base  
##  4 [       difftime        TRUE    base  
##  5 [       Dlist           TRUE    base  
##  6 [       DLLInfoList     TRUE    base  
##  7 [       factor          TRUE    base  
##  8 [       hexmode         TRUE    base  
##  9 [       listof          TRUE    base  
## 10 [       noquote         TRUE    base  
## 11 [       numeric_version TRUE    base  
## 12 [       octmode         TRUE    base  
## 13 [       POSIXct         TRUE    base  
## 14 [       POSIXlt         TRUE    base  
## 15 [       simple.list     TRUE    base  
## 16 [       table           TRUE    base  
## 17 [       warnings        TRUE    base
```


```r
visible_args <- visible %>% 
  mutate(
    method = paste0("[.", class),
    argnames = purrr::map(method, ~ names(formals(.x))),
    args = purrr::map(method, ~ formals(.x)),
    args = purrr::map2(
      argnames, args,
      ~ paste(.x, .y, sep = " = ")
    ),
    args = purrr::set_names(args, method)
  ) 

visible_args
```

```
## # A tibble: 17 Ã— 7
##    generic class           visible source method            argnames  args      
##    <chr>   <chr>           <lgl>   <chr>  <chr>             <list>    <named li>
##  1 [       AsIs            TRUE    base   [.AsIs            <chr [3]> <chr [3]> 
##  2 [       data.frame      TRUE    base   [.data.frame      <chr [4]> <chr [4]> 
##  3 [       Date            TRUE    base   [.Date            <chr [3]> <chr [3]> 
##  4 [       difftime        TRUE    base   [.difftime        <chr [3]> <chr [3]> 
##  5 [       Dlist           TRUE    base   [.Dlist           <chr [3]> <chr [3]> 
##  6 [       DLLInfoList     TRUE    base   [.DLLInfoList     <chr [2]> <chr [2]> 
##  7 [       factor          TRUE    base   [.factor          <chr [3]> <chr [3]> 
##  8 [       hexmode         TRUE    base   [.hexmode         <chr [2]> <chr [2]> 
##  9 [       listof          TRUE    base   [.listof          <chr [3]> <chr [3]> 
## 10 [       noquote         TRUE    base   [.noquote         <chr [2]> <chr [2]> 
## 11 [       numeric_version TRUE    base   [.numeric_version <chr [3]> <chr [3]> 
## 12 [       octmode         TRUE    base   [.octmode         <chr [2]> <chr [2]> 
## 13 [       POSIXct         TRUE    base   [.POSIXct         <chr [3]> <chr [3]> 
## 14 [       POSIXlt         TRUE    base   [.POSIXlt         <chr [4]> <chr [4]> 
## 15 [       simple.list     TRUE    base   [.simple.list     <chr [3]> <chr [3]> 
## 16 [       table           TRUE    base   [.table           <chr [5]> <chr [5]> 
## 17 [       warnings        TRUE    base   [.warnings        <chr [2]> <chr [2]>
```

```r
str(visible_args)
```

```
## tibble [17 Ã— 7] (S3: tbl_df/tbl/data.frame)
##  $ generic : chr [1:17] "[" "[" "[" "[" ...
##  $ class   : chr [1:17] "AsIs" "data.frame" "Date" "difftime" ...
##  $ visible : logi [1:17] TRUE TRUE TRUE TRUE TRUE TRUE ...
##  $ source  : chr [1:17] "base" "base" "base" "base" ...
##  $ method  : chr [1:17] "[.AsIs" "[.data.frame" "[.Date" "[.difftime" ...
##  $ argnames:List of 17
##   ..$ : chr [1:3] "x" "i" "..."
##   ..$ : chr [1:4] "x" "i" "j" "drop"
##   ..$ : chr [1:3] "x" "..." "drop"
##   ..$ : chr [1:3] "x" "..." "drop"
##   ..$ : chr [1:3] "x" "i" "..."
##   ..$ : chr [1:2] "x" "..."
##   ..$ : chr [1:3] "x" "..." "drop"
##   ..$ : chr [1:2] "x" "i"
##   ..$ : chr [1:3] "x" "i" "..."
##   ..$ : chr [1:2] "x" "..."
##   ..$ : chr [1:3] "x" "i" "j"
##   ..$ : chr [1:2] "x" "i"
##   ..$ : chr [1:3] "x" "..." "drop"
##   ..$ : chr [1:4] "x" "i" "j" "drop"
##   ..$ : chr [1:3] "x" "i" "..."
##   ..$ : chr [1:5] "x" "i" "j" "..." ...
##   ..$ : chr [1:2] "x" "..."
##  $ args    :List of 17
##   ..$ [.AsIs           : chr [1:3] "x = " "i = " "... = "
##   ..$ [.data.frame     : chr [1:4] "x = " "i = " "j = " "drop = if (missing(i)) TRUE else length(cols) == 1"
##   ..$ [.Date           : chr [1:3] "x = " "... = " "drop = TRUE"
##   ..$ [.difftime       : chr [1:3] "x = " "... = " "drop = TRUE"
##   ..$ [.Dlist          : chr [1:3] "x = " "i = " "... = "
##   ..$ [.DLLInfoList    : chr [1:2] "x = " "... = "
##   ..$ [.factor         : chr [1:3] "x = " "... = " "drop = FALSE"
##   ..$ [.hexmode        : chr [1:2] "x = " "i = "
##   ..$ [.listof         : chr [1:3] "x = " "i = " "... = "
##   ..$ [.noquote        : chr [1:2] "x = " "... = "
##   ..$ [.numeric_version: chr [1:3] "x = " "i = " "j = "
##   ..$ [.octmode        : chr [1:2] "x = " "i = "
##   ..$ [.POSIXct        : chr [1:3] "x = " "... = " "drop = TRUE"
##   ..$ [.POSIXlt        : chr [1:4] "x = " "i = " "j = " "drop = TRUE"
##   ..$ [.simple.list    : chr [1:3] "x = " "i = " "... = "
##   ..$ [.table          : chr [1:5] "x = " "i = " "j = " "... = " ...
##   ..$ [.warnings       : chr [1:2] "x = " "... = "
```

> pull() is similar to $. It's mostly useful because it looks a little nicer in pipes, it also works with remote data frames, and it can optionally name the output.


```r
visible_args %>%
  pull(args) 
```

```
## $`[.AsIs`
## [1] "x = "   "i = "   "... = "
## 
## $`[.data.frame`
## [1] "x = "                                              
## [2] "i = "                                              
## [3] "j = "                                              
## [4] "drop = if (missing(i)) TRUE else length(cols) == 1"
## 
## $`[.Date`
## [1] "x = "        "... = "      "drop = TRUE"
## 
## $`[.difftime`
## [1] "x = "        "... = "      "drop = TRUE"
## 
## $`[.Dlist`
## [1] "x = "   "i = "   "... = "
## 
## $`[.DLLInfoList`
## [1] "x = "   "... = "
## 
## $`[.factor`
## [1] "x = "         "... = "       "drop = FALSE"
## 
## $`[.hexmode`
## [1] "x = " "i = "
## 
## $`[.listof`
## [1] "x = "   "i = "   "... = "
## 
## $`[.noquote`
## [1] "x = "   "... = "
## 
## $`[.numeric_version`
## [1] "x = " "i = " "j = "
## 
## $`[.octmode`
## [1] "x = " "i = "
## 
## $`[.POSIXct`
## [1] "x = "        "... = "      "drop = TRUE"
## 
## $`[.POSIXlt`
## [1] "x = "        "i = "        "j = "        "drop = TRUE"
## 
## $`[.simple.list`
## [1] "x = "   "i = "   "... = "
## 
## $`[.table`
## [1] "x = "        "i = "        "j = "        "... = "      "drop = TRUE"
## 
## $`[.warnings`
## [1] "x = "   "... = "
```


## 13.5 Object styles
\index{S3!object styles}

So far I've focussed on vector style classes like `Date` and `factor`. These have the key property that `length(x)` represents the number of observations in the vector. There are three variants that do not have this property:

*   Record style objects use a list of equal-length vectors to represent 
    individual components of the object. The best example of this is `POSIXlt`,
    which underneath the hood is a list of 11 date-time components like year, 
    month, and day. Record style classes override `length()` and subsetting 
    methods to conceal this implementation detail.
   
    
    ```r
    x <- as.POSIXlt(ISOdatetime(2020, 1, 1, 0, 0, 1:3))
    x
    ```
    
    ```
    ## [1] "2020-01-01 00:00:01 GMT" "2020-01-01 00:00:02 GMT"
    ## [3] "2020-01-01 00:00:03 GMT"
    ```
    
    ```r
    length(x)
    ```
    
    ```
    ## [1] 3
    ```
    
    ```r
    length(unclass(x))
    ```
    
    ```
    ## [1] 11
    ```
    
    ```r
    x[[1]] # the first date time
    ```
    
    ```
    ## [1] "2020-01-01 00:00:01 GMT"
    ```
    
    ```r
    unclass(x)[[1]] # the first component, the number of seconds
    ```
    
    ```
    ## [1] 1 2 3
    ```
    \indexc{POSIXlt}

*   Data frames are similar to record style objects in that both use lists of
    equal length vectors. However, data frames are conceptually two dimensional, 
    and the individual components are readily exposed to the user. The number of
    observations is the number of rows, not the length:
    
    
    ```r
    x <- data.frame(x = 1:100, y = 1:100)
    length(x)
    ```
    
    ```
    ## [1] 2
    ```
    
    ```r
    nrow(x)
    ```
    
    ```
    ## [1] 100
    ```
    \indexc{Date}

*   Scalar objects typically use a list to represent a single thing. 
    For example, an `lm` object is a list of length 12 but it represents one
    model.
    
    
    ```r
    mod <- lm(mpg ~ wt, data = mtcars)
    length(mod)
    ```
    
    ```
    ## [1] 12
    ```
    
    Scalar objects can also be built on top of functions, calls, and 
    environments[^s3-pairlist]. This is less generally useful, but you can see 
    applications in `stats::ecdf()`, R6 (Chapter \@ref(r6)), and
    `rlang::quo()` (Chapter \@ref(quasiquotation)).
    \indexc{lm()}
    
[^s3-pairlist]: You can also build an object on top of a pairlist, but I have yet to find a good reason to do so.

Unfortunately, describing the appropriate use of each of these object styles is beyond the scope of this book. However, you can learn more from the documentation of the vctrs package (<https://vctrs.r-lib.org>); the package also provides constructors and helpers that make implementation of the different styles easier.

### 13.5.1 Exercises

1.  Categorise the objects returned by `lm()`, `factor()`, `table()`, 
    `as.Date()`, `as.POSIXct()` `ecdf()`, `ordered()`, `I()` into the
    styles described above.

* Vector style objects: `factor()`, `table()`, `as.Date()`,  `ordered()`

> For vector style classes, length(x) represents the number of observations. 


```r
factor <- factor(letters[1:20])
str(factor)
```

```
##  Factor w/ 20 levels "a","b","c","d",..: 1 2 3 4 5 6 7 8 9 10 ...
```

```r
length(factor)
```

```
## [1] 20
```


```r
table <- table(letters[1:20])
str(table)
```

```
##  'table' int [1:20(1d)] 1 1 1 1 1 1 1 1 1 1 ...
##  - attr(*, "dimnames")=List of 1
##   ..$ : chr [1:20] "a" "b" "c" "d" ...
```

```r
length(table)
```

```
## [1] 20
```


```r
x <- c("1jan1960", "2jan1960", "31mar1960", "30jul1960")
z <- as.Date(x, "%d%b%Y")

str(z)
```

```
##  Date[1:4], format: "1960-01-01" "1960-01-02" "1960-03-31" "1960-07-30"
```

```r
length(z)
```

```
## [1] 4
```

```r
length(unclass(z))
```

```
## [1] 4
```




```r
ordered <- ordered(rnorm(12))
str(ordered)
```

```
##  Ord.factor w/ 12 levels "-0.641315339864117"<..: 6 9 3 4 1 7 11 8 2 5 ...
```

```r
length(ordered)
```

```
## [1] 12
```


* Record style objects: `as.POSIXct()` 

> Record style objects use a list of equal length elements to represent individual components.


```r
now <- as.POSIXlt(z)

str(now)
```

```
##  POSIXlt[1:4], format: "1960-01-01" "1960-01-02" "1960-03-31" "1960-07-30"
```

```r
length(now)
```

```
## [1] 4
```

```r
length(unclass(now))
```

```
## [1] 9
```

* Data frame objects: NA

> For data frames and matrices, the observations are represented by the rows.

* Scalar objects: `lm()`, `ecdf()`

> Scalar style objects use a list to represent a single thing.


```r
mod <- lm(mpg ~ wt, data = mtcars)
str(mod)
```

```
## List of 12
##  $ coefficients : Named num [1:2] 37.29 -5.34
##   ..- attr(*, "names")= chr [1:2] "(Intercept)" "wt"
##  $ residuals    : Named num [1:32] -2.28 -0.92 -2.09 1.3 -0.2 ...
##   ..- attr(*, "names")= chr [1:32] "Mazda RX4" "Mazda RX4 Wag" "Datsun 710" "Hornet 4 Drive" ...
##  $ effects      : Named num [1:32] -113.65 -29.116 -1.661 1.631 0.111 ...
##   ..- attr(*, "names")= chr [1:32] "(Intercept)" "wt" "" "" ...
##  $ rank         : int 2
##  $ fitted.values: Named num [1:32] 23.3 21.9 24.9 20.1 18.9 ...
##   ..- attr(*, "names")= chr [1:32] "Mazda RX4" "Mazda RX4 Wag" "Datsun 710" "Hornet 4 Drive" ...
##  $ assign       : int [1:2] 0 1
##  $ qr           :List of 5
##   ..$ qr   : num [1:32, 1:2] -5.657 0.177 0.177 0.177 0.177 ...
##   .. ..- attr(*, "dimnames")=List of 2
##   .. .. ..$ : chr [1:32] "Mazda RX4" "Mazda RX4 Wag" "Datsun 710" "Hornet 4 Drive" ...
##   .. .. ..$ : chr [1:2] "(Intercept)" "wt"
##   .. ..- attr(*, "assign")= int [1:2] 0 1
##   ..$ qraux: num [1:2] 1.18 1.05
##   ..$ pivot: int [1:2] 1 2
##   ..$ tol  : num 1e-07
##   ..$ rank : int 2
##   ..- attr(*, "class")= chr "qr"
##  $ df.residual  : int 30
##  $ xlevels      : Named list()
##  $ call         : language lm(formula = mpg ~ wt, data = mtcars)
##  $ terms        :Classes 'terms', 'formula'  language mpg ~ wt
##   .. ..- attr(*, "variables")= language list(mpg, wt)
##   .. ..- attr(*, "factors")= int [1:2, 1] 0 1
##   .. .. ..- attr(*, "dimnames")=List of 2
##   .. .. .. ..$ : chr [1:2] "mpg" "wt"
##   .. .. .. ..$ : chr "wt"
##   .. ..- attr(*, "term.labels")= chr "wt"
##   .. ..- attr(*, "order")= int 1
##   .. ..- attr(*, "intercept")= int 1
##   .. ..- attr(*, "response")= int 1
##   .. ..- attr(*, ".Environment")=<environment: R_GlobalEnv> 
##   .. ..- attr(*, "predvars")= language list(mpg, wt)
##   .. ..- attr(*, "dataClasses")= Named chr [1:2] "numeric" "numeric"
##   .. .. ..- attr(*, "names")= chr [1:2] "mpg" "wt"
##  $ model        :'data.frame':	32 obs. of  2 variables:
##   ..$ mpg: num [1:32] 21 21 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 ...
##   ..$ wt : num [1:32] 2.62 2.88 2.32 3.21 3.44 ...
##   ..- attr(*, "terms")=Classes 'terms', 'formula'  language mpg ~ wt
##   .. .. ..- attr(*, "variables")= language list(mpg, wt)
##   .. .. ..- attr(*, "factors")= int [1:2, 1] 0 1
##   .. .. .. ..- attr(*, "dimnames")=List of 2
##   .. .. .. .. ..$ : chr [1:2] "mpg" "wt"
##   .. .. .. .. ..$ : chr "wt"
##   .. .. ..- attr(*, "term.labels")= chr "wt"
##   .. .. ..- attr(*, "order")= int 1
##   .. .. ..- attr(*, "intercept")= int 1
##   .. .. ..- attr(*, "response")= int 1
##   .. .. ..- attr(*, ".Environment")=<environment: R_GlobalEnv> 
##   .. .. ..- attr(*, "predvars")= language list(mpg, wt)
##   .. .. ..- attr(*, "dataClasses")= Named chr [1:2] "numeric" "numeric"
##   .. .. .. ..- attr(*, "names")= chr [1:2] "mpg" "wt"
##  - attr(*, "class")= chr "lm"
```

```r
length(mod)
```

```
## [1] 12
```


```r
x <- rnorm(12)
Fn <- ecdf(x)
str(Fn)
```

```
## function (v)  
##  - attr(*, "class")= chr [1:3] "ecdf" "stepfun" "function"
##  - attr(*, "call")= language ecdf(x)
```

```r
length(Fn)
```

```
## [1] 1
```

> `I(x)` depends on the input

> Change the class of an object to indicate that it should be treated â€˜as isâ€™.

2.  What would a constructor function for `lm` objects, `new_lm()`, look like?
    Use `?lm` and experimentation to figure out the required fields and their
    types.
    

```r
lm
```

```
## function (formula, data, subset, weights, na.action, method = "qr", 
##     model = TRUE, x = FALSE, y = FALSE, qr = TRUE, singular.ok = TRUE, 
##     contrasts = NULL, offset, ...) 
## {
##     ret.x <- x
##     ret.y <- y
##     cl <- match.call()
##     mf <- match.call(expand.dots = FALSE)
##     m <- match(c("formula", "data", "subset", "weights", "na.action", 
##         "offset"), names(mf), 0L)
##     mf <- mf[c(1L, m)]
##     mf$drop.unused.levels <- TRUE
##     mf[[1L]] <- quote(stats::model.frame)
##     mf <- eval(mf, parent.frame())
##     if (method == "model.frame") 
##         return(mf)
##     else if (method != "qr") 
##         warning(gettextf("method = '%s' is not supported. Using 'qr'", 
##             method), domain = NA)
##     mt <- attr(mf, "terms")
##     y <- model.response(mf, "numeric")
##     w <- as.vector(model.weights(mf))
##     if (!is.null(w) && !is.numeric(w)) 
##         stop("'weights' must be a numeric vector")
##     offset <- model.offset(mf)
##     mlm <- is.matrix(y)
##     ny <- if (mlm) 
##         nrow(y)
##     else length(y)
##     if (!is.null(offset)) {
##         if (!mlm) 
##             offset <- as.vector(offset)
##         if (NROW(offset) != ny) 
##             stop(gettextf("number of offsets is %d, should equal %d (number of observations)", 
##                 NROW(offset), ny), domain = NA)
##     }
##     if (is.empty.model(mt)) {
##         x <- NULL
##         z <- list(coefficients = if (mlm) matrix(NA_real_, 0, 
##             ncol(y)) else numeric(), residuals = y, fitted.values = 0 * 
##             y, weights = w, rank = 0L, df.residual = if (!is.null(w)) sum(w != 
##             0) else ny)
##         if (!is.null(offset)) {
##             z$fitted.values <- offset
##             z$residuals <- y - offset
##         }
##     }
##     else {
##         x <- model.matrix(mt, mf, contrasts)
##         z <- if (is.null(w)) 
##             lm.fit(x, y, offset = offset, singular.ok = singular.ok, 
##                 ...)
##         else lm.wfit(x, y, w, offset = offset, singular.ok = singular.ok, 
##             ...)
##     }
##     class(z) <- c(if (mlm) "mlm", "lm")
##     z$na.action <- attr(mf, "na.action")
##     z$offset <- offset
##     z$contrasts <- attr(x, "contrasts")
##     z$xlevels <- .getXlevels(mt, mf)
##     z$call <- cl
##     z$terms <- mt
##     if (model) 
##         z$model <- mf
##     if (ret.x) 
##         z$x <- x
##     if (ret.y) 
##         z$y <- y
##     if (!qr) 
##         z$qr <- NULL
##     z
## }
## <bytecode: 0x0000025a09f03390>
## <environment: namespace:stats>
```


```r
mod <- lm(mpg ~ wt, data = mtcars)
typeof(mod)
```

```
## [1] "list"
```

```r
length(mod)
```

```
## [1] 12
```

```r
summary(mod)
```

```
## 
## Call:
## lm(formula = mpg ~ wt, data = mtcars)
## 
## Residuals:
##     Min      1Q  Median      3Q     Max 
## -4.5432 -2.3647 -0.1252  1.4096  6.8727 
## 
## Coefficients:
##             Estimate Std. Error t value Pr(>|t|)    
## (Intercept)  37.2851     1.8776  19.858  < 2e-16 ***
## wt           -5.3445     0.5591  -9.559 1.29e-10 ***
## ---
## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
## 
## Residual standard error: 3.046 on 30 degrees of freedom
## Multiple R-squared:  0.7528,	Adjusted R-squared:  0.7446 
## F-statistic: 91.38 on 1 and 30 DF,  p-value: 1.294e-10
```


```r
str(mod)
```

```
## List of 12
##  $ coefficients : Named num [1:2] 37.29 -5.34
##   ..- attr(*, "names")= chr [1:2] "(Intercept)" "wt"
##  $ residuals    : Named num [1:32] -2.28 -0.92 -2.09 1.3 -0.2 ...
##   ..- attr(*, "names")= chr [1:32] "Mazda RX4" "Mazda RX4 Wag" "Datsun 710" "Hornet 4 Drive" ...
##  $ effects      : Named num [1:32] -113.65 -29.116 -1.661 1.631 0.111 ...
##   ..- attr(*, "names")= chr [1:32] "(Intercept)" "wt" "" "" ...
##  $ rank         : int 2
##  $ fitted.values: Named num [1:32] 23.3 21.9 24.9 20.1 18.9 ...
##   ..- attr(*, "names")= chr [1:32] "Mazda RX4" "Mazda RX4 Wag" "Datsun 710" "Hornet 4 Drive" ...
##  $ assign       : int [1:2] 0 1
##  $ qr           :List of 5
##   ..$ qr   : num [1:32, 1:2] -5.657 0.177 0.177 0.177 0.177 ...
##   .. ..- attr(*, "dimnames")=List of 2
##   .. .. ..$ : chr [1:32] "Mazda RX4" "Mazda RX4 Wag" "Datsun 710" "Hornet 4 Drive" ...
##   .. .. ..$ : chr [1:2] "(Intercept)" "wt"
##   .. ..- attr(*, "assign")= int [1:2] 0 1
##   ..$ qraux: num [1:2] 1.18 1.05
##   ..$ pivot: int [1:2] 1 2
##   ..$ tol  : num 1e-07
##   ..$ rank : int 2
##   ..- attr(*, "class")= chr "qr"
##  $ df.residual  : int 30
##  $ xlevels      : Named list()
##  $ call         : language lm(formula = mpg ~ wt, data = mtcars)
##  $ terms        :Classes 'terms', 'formula'  language mpg ~ wt
##   .. ..- attr(*, "variables")= language list(mpg, wt)
##   .. ..- attr(*, "factors")= int [1:2, 1] 0 1
##   .. .. ..- attr(*, "dimnames")=List of 2
##   .. .. .. ..$ : chr [1:2] "mpg" "wt"
##   .. .. .. ..$ : chr "wt"
##   .. ..- attr(*, "term.labels")= chr "wt"
##   .. ..- attr(*, "order")= int 1
##   .. ..- attr(*, "intercept")= int 1
##   .. ..- attr(*, "response")= int 1
##   .. ..- attr(*, ".Environment")=<environment: R_GlobalEnv> 
##   .. ..- attr(*, "predvars")= language list(mpg, wt)
##   .. ..- attr(*, "dataClasses")= Named chr [1:2] "numeric" "numeric"
##   .. .. ..- attr(*, "names")= chr [1:2] "mpg" "wt"
##  $ model        :'data.frame':	32 obs. of  2 variables:
##   ..$ mpg: num [1:32] 21 21 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 ...
##   ..$ wt : num [1:32] 2.62 2.88 2.32 3.21 3.44 ...
##   ..- attr(*, "terms")=Classes 'terms', 'formula'  language mpg ~ wt
##   .. .. ..- attr(*, "variables")= language list(mpg, wt)
##   .. .. ..- attr(*, "factors")= int [1:2, 1] 0 1
##   .. .. .. ..- attr(*, "dimnames")=List of 2
##   .. .. .. .. ..$ : chr [1:2] "mpg" "wt"
##   .. .. .. .. ..$ : chr "wt"
##   .. .. ..- attr(*, "term.labels")= chr "wt"
##   .. .. ..- attr(*, "order")= int 1
##   .. .. ..- attr(*, "intercept")= int 1
##   .. .. ..- attr(*, "response")= int 1
##   .. .. ..- attr(*, ".Environment")=<environment: R_GlobalEnv> 
##   .. .. ..- attr(*, "predvars")= language list(mpg, wt)
##   .. .. ..- attr(*, "dataClasses")= Named chr [1:2] "numeric" "numeric"
##   .. .. .. ..- attr(*, "names")= chr [1:2] "mpg" "wt"
##  - attr(*, "class")= chr "lm"
```



```r
attributes(mod)
```

```
## $names
##  [1] "coefficients"  "residuals"     "effects"       "rank"         
##  [5] "fitted.values" "assign"        "qr"            "df.residual"  
##  [9] "xlevels"       "call"          "terms"         "model"        
## 
## $class
## [1] "lm"
```




```r
new_lm <- function(coefficients, 
                   residuals, 
                   effects, 
                   rank, 
                   fitted.values, 
                   assign,
                   qr, 
                   df.residual, 
                   xlevels, 
                   call, 
                   terms, 
                   model) {
  
  stopifnot(is.double(coefficients), 
            is.double(residuals), 
            is.double(effects), 
            is.integer(rank), 
            is.double(fitted.values),
            is.integer(assign), 
            is.list(qr), 
            is.integer(df.residual),
            is.list(xlevels), 
            is.language(call), 
            is.language(terms),
            is.list(model)
  )
  
  structure(
    list(
      coefficients = coefficients,
      residuals = residuals,
      effects = effects,
      rank = rank, 
      fitted.values = fitted.values,
      assign = assign,
      qr = qr,
      df.residual = df.residual,
      xlevels = xlevels,
      call = call,
      terms = terms, 
      model = model
    ),
    class = "lm"
  )
}
```

