---
title: "Ch15_S4"
author: "Min-Yao"
date: "2023-04-15"
output: 
  html_document: 
    keep_md: yes
---


```r
library(tidyverse)
```

```
## ── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──
## ✔ dplyr     1.1.0     ✔ readr     2.1.4
## ✔ forcats   1.0.0     ✔ stringr   1.5.0
## ✔ ggplot2   3.4.1     ✔ tibble    3.2.1
## ✔ lubridate 1.9.2     ✔ tidyr     1.3.0
## ✔ purrr     1.0.1     
## ── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──
## ✖ dplyr::filter() masks stats::filter()
## ✖ dplyr::lag()    masks stats::lag()
## ℹ Use the ]8;;http://conflicted.r-lib.org/conflicted package]8;; to force all conflicts to become errors
```


# 15 S4

## 15.1 Introduction

S4 provides a formal approach to functional OOP. The underlying ideas are similar to S3 (the topic of Chapter \@ref(s3)), but implementation is much stricter and makes use of specialised functions for creating classes (`setClass()`), generics (`setGeneric()`), and methods (`setMethod()`). Additionally, S4 provides both multiple inheritance (i.e. a class can have multiple parents) and multiple dispatch (i.e. method dispatch can use the class of multiple arguments).

An important new component of S4 is the __slot__, a named component of the object that is accessed using the specialised subsetting operator `@` (pronounced at). The set of slots, and their classes, forms an important part of the definition of an S4 class.

### Outline {-}

* Section \@ref(s4-basics) gives a quick overview of the main components of S4:
  classes, generics, and methods.
  
* Section \@ref(s4-classes) dives into the details of S4 classes, including
  prototypes, constructors, helpers, and validators.
  
* Section \@ref(s4-generics) shows you how to create new S4 generics, and 
  how to supply those generics with methods. You'll also learn about
  accessor functions which are designed to allow users to safely inspect and 
  modify object slots.
  
* Section \@ref(s4-dispatch) dives into the full details of method dispatch
  in S4. The basic idea is simple, then it rapidly gets more complex once
  multiple inheritance and multiple dispatch are combined.
  
* Section \@ref(s4-s3) discusses the interaction between S4 and S3, showing
  you how to use them together.

### Learning more {-}

Like the other OO chapters, the focus here will be on how S4 works, not how to deploy it most effectively. If you do want to use it in practice, there are two main challenges:

* There is no one reference that will answer all your questions about S4.

* R's built-in documentation sometimes clashes with community best practices.

As you move towards more advanced usage, you will need to piece together needed information by carefully reading the documentation, asking questions on StackOverflow, and performing experiments. Some recommendations:

*   The Bioconductor community is a long-term user of S4 and has produced much of
    the best material about its effective use. Start with [S4 classes and
    methods][bioc-s4-class] taught by Martin Morgan and Hervé Pagès, or
    check for a newer version at [Bioconductor course materials][bioc-courses].
  
    Martin Morgan is a member of R-core and the project lead of Bioconductor.
    He's a world expert on the practical use of S4, and I recommend reading
    anything he has written about it, starting with the questions he has 
    answered on [stackoverflow][SO-Morgan].

*   John Chambers is the author of the S4 system, and provides an overview      
    of its motivation and historical context in _Object-oriented programming,
    functional programming and R_ [@chambers-2014]. For a fuller exploration
    of S4, see his book _Software for Data Analysis_ [@s4da].

### Prerequisites {-}

All functions related to S4 live in the methods package. This package is always available when you're running R interactively, but may not be available when running R in batch mode, i.e. from `Rscript`[^Rscript]. For this reason, it's a good idea to call `library(methods)` whenever you use S4. This also signals to the reader that you'll be using the S4 object system.

[^Rscript]: This is a historical quirk introduced because the methods package used to take a long time to load and `Rscript` is optimised for fast command line invocation.


```r
library(methods)
```

## 15.2 Basics {#s4-basics}

We'll start with a quick overview of the main components of S4. You define an S4 class by calling `setClass()` with the class name and a definition of its slots, and the names and classes of the class data:


```r
setClass("Person", 
  slots = c(
    name = "character", 
    age = "numeric"
  )
)
```

Once the class is defined, you can construct new objects from it by calling `new()` with the name of the class and a value for each slot:


```r
john <- new("Person", name = "John Smith", age = NA_real_)
```

\indexc{"@}
\indexc{slot()}
\index{subsetting!S4} 
\index{S4!subsetting}

Given an S4 object you can see its class with `is()` and access slots with `@` (equivalent to `$`) and `slot()` (equivalent to `[[`):


```r
is(john)
```

```
## [1] "Person"
```

```r
john@name
```

```
## [1] "John Smith"
```

```r
slot(john, "age")
```

```
## [1] NA
```

Generally, you should only use `@` in your methods. If you're working with someone else's class, look for __accessor__ functions that allow you to safely set and get slot values. As the developer of a class, you should also provide your own accessor functions. Accessors are typically S4 generics allowing multiple classes to share the same external interface.

Here we'll create a setter and getter for the `age` slot by first creating generics with `setGeneric()`:


```r
setGeneric("age", function(x) standardGeneric("age"))
```

```
## [1] "age"
```

```r
setGeneric("age<-", function(x, value) standardGeneric("age<-"))
```

```
## [1] "age<-"
```

And then defining methods with `setMethod()`:


```r
setMethod("age", "Person", function(x) x@age)
setMethod("age<-", "Person", function(x, value) {
  x@age <- value
  x
})

age(john) <- 50
age(john)
```

```
## [1] 50
```

If you're using an S4 class defined in a package, you can get help on it with `class?Person`. To get help for a method, put `?` in front of a call (e.g. `?age(john)`) and  `?` will use the class of the arguments to figure out which help file you need.

Finally, you can use sloop functions to identify S4 objects and generics found in the wild:


```r
sloop::otype(john)
```

```
## [1] "S4"
```

```r
sloop::ftype(age)
```

```
## [1] "S4"      "generic"
```

### 15.2.1 Exercises

1.  `lubridate::period()` returns an S4 class. What slots does it have?
    What class is each slot? What accessors does it provide?

> `period()` creates or parses a period object with the specified values.




```r
library(lubridate)

period(c(90, 5), c("second", "minute"))
```

```
## [1] "5M 90S"
```

```r
period(-1, "days")
```

```
## [1] "-1d 0H 0M 0S"
```

```r
period(c(3, 1, 2, 13, 1), c("second", "minute", "hour", "day", "week"))
```

```
## [1] "20d 2H 1M 3S"
```

```r
period(c(1, -60), c("hour", "minute"))
```

```
## [1] "1H -60M 0S"
```

```r
period(0, "second")
```

```
## [1] "0S"
```

```r
test_period <- lubridate::period(
  c(1, 2, 3, 4, 5, 6, 7), 
  c("year", "month", "week", "day", "hour", "minute", "second")
)

test_period
```

```
## [1] "1y 2m 25d 5H 6M 7S"
```


```r
str(test_period)
```

```
## Formal class 'Period' [package "lubridate"] with 6 slots
##   ..@ .Data : num 7
##   ..@ year  : num 1
##   ..@ month : num 2
##   ..@ day   : num 25
##   ..@ hour  : num 5
##   ..@ minute: num 6
```


```r
per <- lubridate::period()
tibble(name=slotNames(per),
       class=map_chr(name, ~ class(getElement(per, .x))))
```

```
## # A tibble: 6 × 2
##   name   class  
##   <chr>  <chr>  
## 1 .Data  numeric
## 2 year   numeric
## 3 month  numeric
## 4 day    numeric
## 5 hour   numeric
## 6 minute numeric
```


```r
second(test_period)
```

```
## [1] 7
```


What slots does it have?
>  Objects of the S4 Period class have six slots named year, month, day, hour, minute, and .Data.

What class is each slot?
> numbers (double)

What accessors does it provide?
> Besides the main constructor and parser period(), period objects can also be created with the specialized functions years(), months(), weeks(), days(), hours(), minutes(), and seconds(). 

2.  What other ways can you find help for a method? Read `?"?"` and
    summarise the details.
    
> Besides adding ? in front of a function call (i.e. ?method()), we may find:

* general documentation for a generic via `?genericName`
* general documentation for the methods of a generic via `methods?genericName`
* documentation for a specific method via `ClassName?methodName`.

## 15.3 Classes {#s4-classes}
\index{classes!S4}
\index{S4!classes}
\indexc{setClass()}

To define an S4 class, call `setClass()` with three arguments:

* The class __name__. By convention, S4 class names use `UpperCamelCase`.

* A named character vector that describes the names and classes of the 
  __slots__ (fields). For example, a person might be represented by a character 
  name and a numeric  age: `c(name = "character", age = "numeric")`. The 
  pseudo-class `ANY` allows a slot to accept objects of any type.

* A __prototype__, a list of default values for each slot. Technically,
  the prototype is optional[^prototype-docs], but you should always provide it.

[^prototype-docs]: `?setClass` recommends that you avoid the `prototype` argument, but this is generally considered to be bad advice.

The code below illustrates the three arguments by creating a `Person` class with character `name` and numeric `age` slots.


```r
setClass("Person", 
  slots = c(
    name = "character", 
    age = "numeric"
  ), 
  prototype = list(
    name = NA_character_,
    age = NA_real_
  )
)

me <- new("Person", name = "Hadley")
str(me)
```

```
## Formal class 'Person' [package ".GlobalEnv"] with 2 slots
##   ..@ name: chr "Hadley"
##   ..@ age : num NA
```

### 15.3.1 Inheritance
\index{S4!inheritance}
\index{inheritance!S4}

There is one other important argument to `setClass()`: `contains`. This specifies a class (or classes) to inherit slots and behaviour from. For example, we can create an `Employee` class that inherits from the `Person` class, adding an extra slot that describes their `boss`.


```r
setClass("Employee", 
  contains = "Person", 
  slots = c(
    boss = "Person"
  ),
  prototype = list(
    boss = new("Person")
  )
)

str(new("Employee"))
```

```
## Formal class 'Employee' [package ".GlobalEnv"] with 3 slots
##   ..@ boss:Formal class 'Person' [package ".GlobalEnv"] with 2 slots
##   .. .. ..@ name: chr NA
##   .. .. ..@ age : num NA
##   ..@ name: chr NA
##   ..@ age : num NA
```

`setClass()` has 9 other arguments but they are either deprecated or not recommended.

### 15.3.2 Introspection
\index{S4!introspection}
\indexc{is()}

To determine what classes an object inherits from, use `is()`:


```r
is(new("Person"))
```

```
## [1] "Person"
```

```r
is(new("Employee"))
```

```
## [1] "Employee" "Person"
```

To test if an object inherits from a specific class, use the second argument of `is()`:


```r
is(john, "Person")
```

```
## [1] TRUE
```

### 15.3.3 Redefinition

In most programming languages, class definition occurs at compile-time and object construction occurs later, at run-time. In R, however, both definition and construction occur at run time. When you call `setClass()`, you are registering a class definition in a (hidden) global variable. As with all state-modifying functions you need to use `setClass()` with care. It's possible to create invalid objects if you redefine a class after already having instantiated an object:


```r
setClass("A", slots = c(x = "numeric"))
a <- new("A", x = 10)

setClass("A", slots = c(a_different_slot = "numeric"))
# a <- new("A", a_different_slot = 10)
a
```

```
## An object of class "A"
## Slot "a_different_slot":
```

```
## Error in slot(object, what): no slot of name "a_different_slot" for this object of class "A"
```

This can cause confusion during interactive creation of new classes. (R6 classes have the same problem, as described in Section \@ref(r6-important-methods).)

### 15.3.4 Helper
\index{helpers!S4}
\index{constructors!S4}
\index{S4!helpers}
\indexc{new()}

`new()` is a low-level constructor suitable for use by you, the developer. User-facing classes should always be paired with a user-friendly helper. A helper should always:

* Have the same name as the class, e.g. `myclass()`.

* Have a thoughtfully crafted user interface with carefully chosen default
  values and useful conversions.

* Create carefully crafted error messages tailored towards an end-user.

* Finish by calling `methods::new()`.

The `Person` class is so simple so a helper is almost superfluous, but we can use it to clearly define the contract: `age` is optional but `name` is required. We'll also coerce age to a double so the helper also works when passed an integer.


```r
Person <- function(name, age = NA) {
  age <- as.double(age)
  
  new("Person", name = name, age = age)
}

Person("Hadley")
```

```
## An object of class "Person"
## Slot "name":
## [1] "Hadley"
## 
## Slot "age":
## [1] NA
```

### 15.3.5 Validator
\index{validators!S4}
\index{S4!validators}
\indexc{setValidity()}

The constructor automatically checks that the slots have correct classes:


```r
Person(mtcars)
```

```
## Error in validObject(.Object): invalid class "Person" object: invalid object for slot "name" in class "Person": got class "data.frame", should be or extend class "character"
```

You will need to implement more complicated checks (i.e. checks that involve lengths, or multiple slots) yourself. For example, we might want to make it clear that the Person class is a vector class, and can store data about multiple people. That's not currently clear because `@name` and `@age` can be different lengths:


```r
Person("Hadley", age = c(30, 37))
```

```
## An object of class "Person"
## Slot "name":
## [1] "Hadley"
## 
## Slot "age":
## [1] 30 37
```

To enforce these additional constraints we write a validator with `setValidity()`. It takes a class and a function that returns `TRUE` if the input is valid, and otherwise returns a character vector describing the problem(s):


```r
setValidity("Person", function(object) {
  if (length(object@name) != length(object@age)) {
    "@name and @age must be same length"
  } else {
    TRUE
  }
})
```

```
## Class "Person" [in ".GlobalEnv"]
## 
## Slots:
##                           
## Name:       name       age
## Class: character   numeric
## 
## Known Subclasses: "Employee"
```

Now we can no longer create an invalid object:


```r
Person("Hadley", age = c(30, 37))
```

```
## Error in validObject(.Object): invalid class "Person" object: @name and @age must be same length
```

NB: The validity method is only called automatically by `new()`, so you can still create an invalid object by modifying it:


```r
alex <- Person("Alex", age = 30)
alex@age <- 1:10
```

\indexc{validObject()}
You can explicitly check the validity yourself by calling `validObject()`:


```r
validObject(alex)
```

```
## Error in validObject(alex): invalid class "Person" object: @name and @age must be same length
```

In Section \@ref(accessors), we'll use `validObject()` to create accessors that can not create invalid objects.

### 15.3.6 Exercises

1.  Extend the Person class with fields to match `utils::person()`.
    Think about what slots you will need, what class each slot should have,
    and what you'll need to check in your validity method.

> The Person class from Advanced R contains the slots name and age. The person class from the {utils} package contains the slots given (vector of given names), family, role, email and comment.


```r
# ?utils::person
```

## Usage


```r
person(given = NULL, family = NULL, middle = NULL,
       email = NULL, role = NULL, comment = NULL,
       first = NULL, last = NULL)
## Default S3 method:
as.person(x)
## S3 method for class 'person'
format(x,
       include = c("given", "family", "email", "role", "comment"),
       braces = list(given = "", family = "", email = c("<", ">"),
                     role = c("[", "]"), comment = c("(", ")")),
       collapse = list(given = " ", family = " ", email = ", ",
                       role = ", ", comment = ", "),
       ...,
       style = c("text", "R")
       )
```

what slots you will need?

> "given", "family", "email", "role", "comment"

what class each slot should have?

> All slots from utils::person() besides role must be of type character and length 1. Age need to be numeric.


```r
# Definition of the Person class
setClass("Person",
  slots = c(
    age = "numeric",
    given = "character",
    family = "character",
    role = "character",
    email = "character",
    comment = "character"
  ),
  prototype = list(
    age = NA_real_,
    given = NA_character_,
    family = NA_character_,
    role = NA_character_,
    email = NA_character_,
    comment = NA_character_
  )
)
```


```r
# Helper to create instances of the Person class
Person <- function(given, family,
                   age = NA_real_,
                   role = NA_character_,
                   email = NA_character_,
                   comment = NA_character_) {
  age <- as.double(age)

  new("Person",
    age = age,
    given = given,
    family = family,
    role = role,
    email = email,
    comment = comment
  )
}
```

what you'll need to check in your validity method

> The entries in the role slot must match one of the following abbreviations “aut,” “com,” “cph,” “cre,” “ctb,” “ctr,” “dtc,” “fnd,” “rev,” “ths,” “trl.” Therefore, role might be of different length than the other slots and we’ll add a corresponding constraint within the validator.


```r
# Validator to ensure that each slot is of length one
setValidity("Person", function(object) {
  invalids <- c()
  if (length(object@age)     != 1 ||
      length(object@given)   != 1 ||
      length(object@family)  != 1 ||
      length(object@email)   != 1 ||
      length(object@comment) != 1) {
    invalids <- paste0("@name, @age, @given, @family, @email, ",
                       "@comment must be of length 1")
  } 
  
  known_roles <- c(
    NA_character_, "aut", "com", "cph", "cre", "ctb",
    "ctr", "dtc", "fnd", "rev", "ths", "trl"
  )
  
  if (!all(object@role %in% known_roles)) {
    paste(
      "@role(s) must be one of", 
      paste(known_roles, collapse = ", ")
    )
  }
  
  if (length(invalids)) return(invalids)  
  TRUE
})
```

```
## Class "Person" [in ".GlobalEnv"]
## 
## Slots:
##                                                                   
## Name:        age     given    family      role     email   comment
## Class:   numeric character character character character character
```


2.  What happens if you define a new S4 class that doesn't have any slots?
    (Hint: read about virtual classes in `?setClass`.)

> It depends on the other arguments. 

> If we don’t inherit from an existing class. We get a virtual class. If the class is virtual, an attempt to generate an object from either the generator or new() will result in an error.
    

```r
setClass("Human")
new("Human")
```

```
## Error in new("Human"): trying to generate an object from a virtual class ("Human")
```

> If we inherit from another class, we get the same slots.

But can be inherited from:


```r
setClass("Programmer", contains = "Human")
new("Programmer")
```

```
## An object of class "Programmer"
## <S4 Type Object>
```

```r
Programmer <- new("Programmer")
str(Programmer)
```

```
## Formal class 'Programmer' [package ".GlobalEnv"] with 0 slots
##  list()
```


3.  Imagine you were going to reimplement factors, dates, and data frames in 
    S4. Sketch out the `setClass()` calls that you would use to define the 
    classes. Think about appropriate `slots` and `prototype`.

> For all these classes we need one slot for the data and one slot per attribute. Keep in mind, that inheritance matters for ordered factors and dates. For data frames, special checks like equal lengths of the underlying list’s elements should be done within a validator.

> For simplicity we don’t introduce an explicit subclass for ordered factors. Instead, we introduce ordered as a slot.


```r
setClass("Factor",
  slots = c(
    data = "integer",
    levels = "character",
    ordered = "logical"
  ),
  prototype = list(
    data = integer(),
    levels = character(),
    ordered = FALSE
  )
)


new("Factor", data = c(1L, 2L), levels = letters[1:3])
```

```
## An object of class "Factor"
## Slot "data":
## [1] 1 2
## 
## Slot "levels":
## [1] "a" "b" "c"
## 
## Slot "ordered":
## [1] FALSE
```

> The Date2 class stores its dates as integers, similarly to base R which uses doubles. Dates don’t have any other attributes.


```r
setClass("Date2",
  slots = list(
    data = "integer"
  ),
  prototype = list(
    data = integer()
  )
)

new("Date2", data = 1L)
```

```
## An object of class "Date2"
## Slot "data":
## [1] 1
```


```r
setClass("DataFrame",
  slots = c(
    data = "list",
    row.names = "character"
  ),
  prototype = list(
    data = list(),
    row.names = character(0)
  )
)

new("DataFrame", data = list(a = 1, b = 2))
```

```
## An object of class "DataFrame"
## Slot "data":
## $a
## [1] 1
## 
## $b
## [1] 2
## 
## 
## Slot "row.names":
## character(0)
```



