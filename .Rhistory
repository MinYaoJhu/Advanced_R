x <- "local scope"
source(file, local = local)
}
# Where will the source() function execute the code?
determine_evaluation(script_file, local = FALSE)  # default behavior
determine_evaluation(script_file, local = env2)
determine_evaluation(script_file, local = TRUE)
# name is a string
get2 <- function(name, env) {}
assign2 <- function(name, value, env) {}
get
get2 <- function(name, env = current_env()) {
sym_name <- sym(name)
eval(sym_name, env)
}
x <- 10
get2("x")
#get2(x)
assign
assign2 <- function(name, value, env = current_env()) {
sym_name <- sym(name)
assign_expr <- expr(!!sym_name <- !!value)
eval(assign_expr, env)
print(x)
}
assign2("x", 6, .GlobalEnv)
x
print(x)
source2 <- function(path, env = caller_env()) {
file <- paste(readLines(path, warn = FALSE), collapse = "\n")
exprs <- parse_exprs(file)
res <- NULL
for (i in seq_along(exprs)) {
res <- eval(exprs[[i]], env)
}
invisible(res)
}
source2 <- function(path, env = caller_env()) {
file <- paste(readLines(path, warn = FALSE), collapse = "\n")
exprs <- parse_exprs(file)
res <- purrr::map(exprs, eval, env)
invisible(res)
}
# tmp_file <- tempfile()
# writeLines(
#   "x <- 1
#    x
#    y <- 2
#    y  # a comment here",
#   tmp_file
# )
#
# (source2(tmp_file))
local3 <- function(expr, envir = new.env()) {
call <- substitute(eval(quote(expr), envir))
eval(call, envir = parent.frame())
}
local3 <- function(expr, envir = new.env()) {
call <- substitute(eval(quote(expr), envir))
print(call)
eval(call, envir = parent.frame())
}
#?substitute
local3({
x <- 10
x * 2
})
eval(quote({
x <- 10
x * 2
}), new.env())
exists("x")
foo <- function(x) enquo(x)
foo(a + b)
quo(x + y + z)
new_quosure(expr(x + y), env(x = 1, y = 10))
q1 <- new_quosure(expr(x + y), env(x = 1, y = 10))
eval_tidy(q1)
f <- function(...) {
x <- 1
g(..., f = x)
}
g <- function(...) {
enquos(...)
}
x <- 0
qs <- f(global = x)
qs
map_dbl(qs, eval_tidy)
f <- ~runif(3)
str(f)
q4 <- new_quosure(expr(x + y + z))
class(q4)
is_call(q4)
q4[[1]]
q4[[2]]
attr(q4, ".Environment")
get_expr(q4)
get_env(q4)
q2 <- new_quosure(expr(x), env(x = 1))
q3 <- new_quosure(expr(x), env(x = 10))
x <- expr(!!q2 + !!q3)
eval_tidy(x)
x
expr_print(x)
q1 <- new_quosure(expr(x), env(x = 1))
q1
q2 <- new_quosure(expr(x + !!q1), env(x = 10))
q2
q3 <- new_quosure(expr(x + !!q2), env(x = 100))
q3
eval_tidy(q1)
eval_tidy(q2)
eval_tidy(q3)
enenv <- function(quos) {
get_env(enquo(quos))
}
# Verify
enenv(x)
# Confirm functionality within functions as well
gather_env <- function(quos) {
enenv(quos)
}
gather_env(x)
tmp_file <- tempfile()
writeLines(
"x <- 1
x
y <- 2
y  # a comment here",
tmp_file
)
#
# (source2(tmp_file))
source2(tmp_file)
tmp_file <- tempfile()
writeLines("x <- 1
x
y <- 2
y  # a comment here",
tmp_file)
source2(tmp_file)
source2 <- function(path, env = caller_env()) {
file <- paste(readLines(path, warn = FALSE), collapse = "\n")
exprs <- parse_exprs(file)
res <- purrr::map(exprs, eval, env)
invisible(res)
}
assign2 <- function(name, value, env = current_env()) {
sym_name <- sym(name)
assign_expr <- expr(!!sym_name <- !!value)
eval(assign_expr, env)
print(x)
}
assign2("x", 6, .GlobalEnv)
x
assign2 <- function(name, value, env = .GlobalEnv) {
sym_name <- sym(name)
assign_expr <- expr(!!sym_name <- !!value)
eval(assign_expr, env)
print(x)
}
assign2("x", 5)
x
source2 <- function(path, env = caller_env()) {
file <- paste(readLines(path, warn = FALSE), collapse = "\n")
exprs <- parse_exprs(file)
res <- purrr::map2(exprs, eval, env)
invisible(res)
}
tmp_file <- tempfile()
writeLines("x <- 1
x
y <- 2
y  # a comment here",
tmp_file)
source2(tmp_file)
source2 <- function(path, env = caller_env()) {
file <- paste(readLines(path, warn = FALSE), collapse = "\n")
exprs <- parse_exprs(file)
res <- purrr::map(exprs, eval, env)
invisible(res)
}
tmp_file <- tempfile()
writeLines("x <- 1
x
y <- 2
y  # a comment here",
tmp_file)
source2(tmp_file)
q1 <- new_quosure(expr(x * y), env(x = 100))
library(rlang)
library(purrr)
library(rlang)
library(purrr)
q1 <- new_quosure(expr(x * y), env(x = 100))
df <- data.frame(y = 1:10)
eval_tidy(q1, df)
with2 <- function(data, expr) {
expr <- enquo(expr)
eval_tidy(expr, data)
}
x <- 100
with2(df, x * y)
with3 <- function(data, expr) {
expr <- substitute(expr)
eval(expr, data, caller_env())
}
x <- 1
df <- data.frame(x = 2)
with2(df, .data$x)
with2(df, .env$x)
with2(df, .data$y)
sample_df <- data.frame(a = 1:5, b = 5:1, c = c(5, 3, 1, 4, 1))
# Shorthand for sample_df[sample_df$a >= 4, ]
subset(sample_df, a >= 4)
# Shorthand for sample_df[sample_df$b == sample_df$c, ]
subset(sample_df, b == c)
subset2 <- function(data, rows) {
rows <- enquo(rows)
rows_val <- eval_tidy(rows, data)
stopifnot(is.logical(rows_val))
data[rows_val, , drop = FALSE]
}
subset2(sample_df, b == c)
df <- data.frame(x = c(2, 3, 1), y = runif(3))
transform(df, x = -x, y2 = 2 * y)
transform2 <- function(.data, ...) {
dots <- enquos(...)
for (i in seq_along(dots)) {
name <- names(dots)[[i]]
dot <- dots[[i]]
.data[[name]] <- eval_tidy(dot, .data)
}
.data
}
transform2(df, x2 = x * 2, y = -y)
df <- data.frame(a = 1, b = 2, c = 3, d = 4, e = 5)
subset(df, select = b:d)
vars <- as.list(set_names(seq_along(df), names(df)))
str(vars)
select2 <- function(data, ...) {
dots <- enquos(...)
vars <- as.list(set_names(seq_along(data), names(data)))
cols <- unlist(map(dots, eval_tidy, vars))
data[, cols, drop = FALSE]
}
select2(df, b:d)
subset3 <- function(data, rows) {
rows <- enquo(rows)
eval_tidy(expr(data[!!rows, , drop = FALSE]), data = data)
}
df <- data.frame(x = 1:3)
subset3(df, x == 1)
arrange2 <- function(.df, ..., .na.last = TRUE) {
args <- enquos(...)
order_call <- expr(order(!!!args, na.last = !!.na.last))
ord <- eval_tidy(order_call, .df)
stopifnot(length(ord) == nrow(.df))
.df[ord, , drop = FALSE]
}
rm(x)
resample <- function(df, n) {
idx <- sample(nrow(df), n, replace = TRUE)
df[idx, , drop = FALSE]
}
subsample <- function(df, cond, n = nrow(df)) {
df <- subset2(df, cond)
resample(df, n)
}
df <- data.frame(x = c(1, 1, 1, 2, 2), y = 1:5)
subsample(df, x == 1)
subsample <- function(df, cond, n = nrow(df)) {
cond <- enquo(cond)
df <- subset2(df, !!cond)
resample(df, n)
}
subsample(df, x == 1)
threshold_x <- function(df, val) {
subset2(df, x >= val)
}
x <- 10
no_x <- data.frame(y = 1:3)
threshold_x(no_x, 2)
has_val <- data.frame(x = 1:3, val = 9:11)
threshold_x(has_val, 2)
threshold_x <- function(df, val) {
subset2(df, .data$x >= .env$val)
}
x <- 10
threshold_x(no_x, 2)
threshold_x(has_val, 2)
threshold_x <- function(df, val) {
subset2(df, .data$x >= !!val)
}
threshold_var <- function(df, var, val) {
var <- as_string(ensym(var))
subset2(df, .data[[var]] >= !!val)
}
df <- data.frame(x = 1:10)
threshold_var(df, x, 8)
threshold_expr <- function(df, expr, val) {
expr <- enquo(expr)
subset2(df, !!expr >= !!val)
}
threshold_var <- function(df, var, val) {
var <- ensym(var)
subset2(df, `$`(.data, !!var) >= !!val)
}
subset_base <- function(data, rows) {
rows <- substitute(rows)
rows_val <- eval(rows, data, caller_env())
stopifnot(is.logical(rows_val))
data[rows_val, , drop = FALSE]
}
subset_tidy <- function(data, rows) {
rows <- enquo(rows)
rows_val <- eval_tidy(rows, data)
stopifnot(is.logical(rows_val))
data[rows_val, , drop = FALSE]
}
f1 <- function(df, ...) {
xval <- 3
subset_base(df, ...)
}
my_df <- data.frame(x = 1:3, y = 3:1)
xval <- 1
f1(my_df, x == xval)
local({
zzz <- 2
dfs <- list(data.frame(x = 1:3), data.frame(x = 4:6))
lapply(dfs, subset_base, x == zzz)
})
f2 <- function(df1, expr) {
call <- substitute(subset_base(df1, expr))
expr_print(call)
eval(call, caller_env())
}
my_df <- data.frame(x = 1:3, y = 3:1)
f2(my_df, x == 1)
f3 <- function(df) {
call <- substitute(subset_base(df, z > 0))
expr_print(call)
eval(call, caller_env())
}
my_df <- data.frame(x = 1:3, y = 3:1)
z <- -1
f3(my_df)
g <- function(x, y, z) {
match.call()
}
g(1, 2, z = 3)
write.csv <- function(...) {
call <- match.call(write.table, expand.dots = TRUE)
call[[1]] <- quote(write.table)
call$sep <- ","
call$dec <- "."
eval(call, parent.frame())
}
write.csv <- function(...) {
write.table(..., sep = ",", dec = ".")
}
lm2 <- function(formula, data) {
lm(formula, data)
}
lm2(mpg ~ disp, mtcars)
lm3 <- function(formula, data, env = caller_env()) {
formula <- enexpr(formula)
data <- enexpr(data)
lm_call <- expr(lm(!!formula, data = !!data))
expr_print(lm_call)
eval(lm_call, env)
}
lm3(mpg ~ disp, mtcars)
resp <- expr(mpg)
disp1 <- expr(vs)
disp2 <- expr(wt)
lm3(!!resp ~ !!disp1 + !!disp2, mtcars)
resample_lm0 <- function(formula, data, env = caller_env()) {
formula <- enexpr(formula)
resample_data <- resample(data, n = nrow(data))
lm_call <- expr(lm(!!formula, data = resample_data))
expr_print(lm_call)
eval(lm_call, env)
}
df <- data.frame(x = 1:10, y = 5 + 3 * (1:10) + round(rnorm(10), 2))
resample_lm0(y ~ x, data = df)
resample_lm2 <- function(formula, data, env = caller_env()) {
formula <- enexpr(formula)
resample_data <- resample(data, n = nrow(data))
lm_env <- env(env, resample_data = resample_data)
lm_call <- expr(lm(!!formula, data = resample_data))
expr_print(lm_call)
eval(lm_call, lm_env)
}
resample_lm2(y ~ x, data = df)
transform2 <- function(.data, ...) {
dots <- enquos(...)
for (i in seq_along(dots)) {
name <- names(dots)[[i]]
dot <- dots[[i]]
.data[[name]] <- eval_tidy(dot, .data)
}
.data
}
subset2 <- function(data, rows) {
rows <- enquo(rows)
rows_val <- eval_tidy(rows, data)
stopifnot(is.logical(rows_val))
data[rows_val, , drop = FALSE]
}
df <- data.frame(x = 1:3)
subset2(df, x == 1)
# Evaluation of custom subset function - Approach 1
(condition_1 <- eval_tidy(quo(x == 1), df))
custom_subset_1 <- df[condition_1, , drop = FALSE]
df <- data.frame(x = 1:3, data = 1)
subset2(df, x == 1)
subset3(df, x == 1)
threshold_var_2 <- function(df, var, val) {
var <- ensym(var)
subset2(df, `$`(.data,!!var) >= !!val)
}
threshold_var <- function(df, var, val) {
var <- as_string(ensym(var))
subset2(df, .data[[var]] >= !!val)
}
# Sample data frame
df <- data.frame(x = 1:100)
# Using the original threshold_var() function
threshold_var(df, x, 89)
# Using the alternative threshold_var2() function
threshold_var_2(df, x, 89)
lm3a <- function(formula, data) {
formula <- enexpr(formula)
lm_call <- expr(lm(!!formula, data = data))
eval(lm_call, caller_env())
}
lm3a(mpg ~ disp, mtcars)$call
# Approach 1: Modify the evaluation environment
custom_lm3b <- function(formula, data) {
formula <- enexpr(formula)
lm_call <- expr(lm(!!formula, data = data))
eval(lm_call, current_env())
}
custom_lm3b(mpg ~ disp, mtcars)$call
custom_lm3b(mpg ~ disp, data)$call  # Replicates the original error
# Approach 2: Unquoting the data argument
custom_lm3c <- function(formula, data) {
formula <- enexpr(formula)
data_quo <- enexpr(data)
lm_call <- expr(lm(!!formula, data = !!data_quo))
eval(lm_call, caller_env())
}
custom_lm3c(mpg ~ disp, mtcars)$call
# Approach 1: Modify the evaluation environment
custom_lm3b <- function(formula, data) {
formula <- enexpr(formula)
lm_call <- expr(lm(!!formula, data = data))
eval(lm_call, current_env())
}
custom_lm3b(mpg ~ disp, mtcars)$call
# Approach 2: Unquoting the data argument
custom_lm3c <- function(formula, data) {
formula <- enexpr(formula)
data_quo <- enexpr(data)
lm_call <- expr(lm(!!formula, data = !!data_quo))
eval(lm_call, caller_env())
}
custom_lm3c(mpg ~ disp, mtcars)$call
lm(mpg ~ disp, data = mtcars)
lm(mpg ~ I(1 / disp), data = mtcars)
lm(mpg ~ disp * cyl, data = mtcars)
# Custom lm_wrap function and its utility
custom_lm_wrap <- function(predictor, response = mpg, data = mtcars,
environment = caller_env()) {
predictor <- enexpr(predictor)
response <- enexpr(response)
data <- enexpr(data)
formula_expr <- expr(!!response ~ !!predictor)
lm_call_expr <- expr(lm(!!formula_expr, data = !!data))
eval(lm_call_expr, envir = environment)
}
# Verify the output appearance
custom_lm_wrap(I(1 / disp) + disp * cyl)
# Confirm the equivalence of the result to a direct lm() call
identical(
custom_lm_wrap(I(1 / disp) + disp * cyl),
lm(mpg ~ I(1 / disp) + disp * cyl, data = mtcars)
)
# Verify the output appearance
custom_lm_wrap(I(1 / disp) + disp * cyl)
# Confirm the equivalence of the result to a direct lm() call
identical(
custom_lm_wrap(I(1 / disp) + disp * cyl),
lm(mpg ~ I(1 / disp) + disp * cyl, data = mtcars)
)
# Verify the output appearance
custom_lm_wrap(I(1 / disp) + disp * cyl)
custom_resample_lm <- function(
formula, data,
resample_data = data[sample(nrow(data), replace = TRUE), ,
drop = FALSE],
environment = current_env()) {
formula <- enexpr(formula)
lm_call <- expr(lm(!!formula, data = resample_data))
expr_print(lm_call)
eval(lm_call, environment)
}
df <- data.frame(x = 1:10, y = 5 + 3 * (1:10) + round(rnorm(10), 2))
(lm_1 <- custom_resample_lm(y ~ x, data = df))
lm_1$call
