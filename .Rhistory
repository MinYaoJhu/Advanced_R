}
g <- function(...) {
enquos(...)
}
x <- 0
qs <- f(global = x)
qs
map_dbl(qs, eval_tidy)
f <- ~runif(3)
str(f)
q4 <- new_quosure(expr(x + y + z))
class(q4)
is_call(q4)
q4[[1]]
q4[[2]]
attr(q4, ".Environment")
get_expr(q4)
get_env(q4)
q2 <- new_quosure(expr(x), env(x = 1))
q3 <- new_quosure(expr(x), env(x = 10))
x <- expr(!!q2 + !!q3)
eval_tidy(x)
x
expr_print(x)
q1 <- new_quosure(expr(x), env(x = 1))
q1
q2 <- new_quosure(expr(x + !!q1), env(x = 10))
q2
q3 <- new_quosure(expr(x + !!q2), env(x = 100))
q3
q1 <- new_quosure(expr(x), env(x = 1))
q1
q2 <- new_quosure(expr(x + !!q1), env(x = 10))
q2
q3 <- new_quosure(expr(x + !!q2), env(x = 100))
q3
```{r}
eval_tidy(q1)
eval_tidy(q2)
eval_tidy(q3)
enenv <- function(quos) {
get_env(enquo(quos))
}
# Verify
enenv(x)
# Confirm functionality within functions as well
gather_env <- function(quos) {
enenv(quos)
}
gather_env(x)
assign
get
assign2 <- function(name, value, env = current_env()) {
sym_name <- sym(name)
assign_expr <- expr(!!sym_name <- !!value)
eval(assign_expr, env)
}
assign2("x", 5)
x
library(rlang)
library(purrr)
x <- 10
eval(expr(x))
y <- 2
eval(expr(x + y))
eval(expr(x + y), env(x = 1000))
eval(print(x + 1), env(x = 1000))
eval(expr(print(x + 1)), env(x = 1000))
# Clean up variables created earlier
rm(x, y)
foo <- local({
x <- 10
y <- 200
x + y
})
foo
x
y
local2 <- function(expr) {
env <- env(caller_env())
eval(enexpr(expr), env)
}
foo <- local2({
x <- 10
y <- 200
x + y
})
foo
x
y
source2 <- function(path, env = caller_env()) {
file <- paste(readLines(path, warn = FALSE), collapse = "\n")
exprs <- parse_exprs(file)
res <- NULL
for (i in seq_along(exprs)) {
res <- eval(exprs[[i]], env)
}
invisible(res)
}
source3 <- function(file, env = parent.frame()) {
lines <- parse(file)
res <- eval(lines, envir = env)
invisible(res)
}
x <- 10
y <- 20
f <- eval(expr(function(x, y) !!x + !!y))
f
f()
attr(f, "srcref") <- NULL
f
# Generate a transient, source-ready R script designed to display x
script_file <- tempfile()
writeLines("print(x)", script_file)
# Define the value of `x` in the global scope
x <- "global scope"
env2 <- env(x = "specified scope")
determine_evaluation <- function(file, local) {
x <- "local scope"
source(file, local = local)
}
# Where will the source() function execute the code?
determine_evaluation(script_file, local = FALSE)  # default behavior
determine_evaluation(script_file, local = env2)
determine_evaluation(script_file, local = TRUE)
# name is a string
get2 <- function(name, env) {}
assign2 <- function(name, value, env) {}
get
get2 <- function(name, env = current_env()) {
sym_name <- sym(name)
eval(sym_name, env)
}
x <- 10
get2("x")
#get2(x)
assign
assign2 <- function(name, value, env = current_env()) {
sym_name <- sym(name)
assign_expr <- expr(!!sym_name <- !!value)
eval(assign_expr, env)
}
assign2("x", 5)
x
source2 <- function(path, env = caller_env()) {
file <- paste(readLines(path, warn = FALSE), collapse = "\n")
exprs <- parse_exprs(file)
res <- NULL
for (i in seq_along(exprs)) {
res <- eval(exprs[[i]], env)
}
invisible(res)
}
source2 <- function(path, env = caller_env()) {
file <- paste(readLines(path, warn = FALSE), collapse = "\n")
exprs <- parse_exprs(file)
res <- purrr::map(exprs, eval, env)
invisible(res)
}
# tmp_file <- tempfile()
# writeLines(
#   "x <- 1
#    x
#    y <- 2
#    y  # a comment here",
#   tmp_file
# )
#
# (source2(tmp_file))
local3 <- function(expr, envir = new.env()) {
call <- substitute(eval(quote(expr), envir))
eval(call, envir = parent.frame())
}
local3 <- function(expr, envir = new.env()) {
call <- substitute(eval(quote(expr), envir))
print(call)
eval(call, envir = parent.frame())
}
#?substitute
local3({
x <- 10
x * 2
})
eval(quote({
x <- 10
x * 2
}), new.env())
exists("x")
foo <- function(x) enquo(x)
foo(a + b)
quo(x + y + z)
new_quosure(expr(x + y), env(x = 1, y = 10))
q1 <- new_quosure(expr(x + y), env(x = 1, y = 10))
eval_tidy(q1)
f <- function(...) {
x <- 1
g(..., f = x)
}
g <- function(...) {
enquos(...)
}
x <- 0
qs <- f(global = x)
qs
map_dbl(qs, eval_tidy)
f <- ~runif(3)
str(f)
q4 <- new_quosure(expr(x + y + z))
class(q4)
is_call(q4)
q4[[1]]
q4[[2]]
attr(q4, ".Environment")
get_expr(q4)
get_env(q4)
q2 <- new_quosure(expr(x), env(x = 1))
q3 <- new_quosure(expr(x), env(x = 10))
x <- expr(!!q2 + !!q3)
eval_tidy(x)
x
expr_print(x)
q1 <- new_quosure(expr(x), env(x = 1))
q1
q2 <- new_quosure(expr(x + !!q1), env(x = 10))
q2
q3 <- new_quosure(expr(x + !!q2), env(x = 100))
q3
eval_tidy(q1)
eval_tidy(q2)
eval_tidy(q3)
enenv <- function(quos) {
get_env(enquo(quos))
}
# Verify
enenv(x)
# Confirm functionality within functions as well
gather_env <- function(quos) {
enenv(quos)
}
gather_env(x)
assign2("x", 5, .global_env())
assign2("x", 5, .GlobalEnv)
x
assign2("x", 6)
print(x)
assign2 <- function(name, value, env = current_env()) {
sym_name <- sym(name)
assign_expr <- expr(!!sym_name <- !!value)
eval(assign_expr, env)
print(x)
}
assign2("x", 6)
x
print(x)
assign2 <- function(name, value, env = current_env()) {
sym_name <- sym(name)
assign_expr <- expr(!!sym_name <- !!value)
eval(assign_expr, env)
print(x)
}
assign2("x", 6)
x
print(x)
library(rlang)
library(purrr)
x <- 10
eval(expr(x))
y <- 2
eval(expr(x + y))
eval(expr(x + y), env(x = 1000))
eval(print(x + 1), env(x = 1000))
eval(expr(print(x + 1)), env(x = 1000))
# Clean up variables created earlier
rm(x, y)
foo <- local({
x <- 10
y <- 200
x + y
})
foo
x
y
local2 <- function(expr) {
env <- env(caller_env())
eval(enexpr(expr), env)
}
foo <- local2({
x <- 10
y <- 200
x + y
})
foo
x
y
source2 <- function(path, env = caller_env()) {
file <- paste(readLines(path, warn = FALSE), collapse = "\n")
exprs <- parse_exprs(file)
res <- NULL
for (i in seq_along(exprs)) {
res <- eval(exprs[[i]], env)
}
invisible(res)
}
source3 <- function(file, env = parent.frame()) {
lines <- parse(file)
res <- eval(lines, envir = env)
invisible(res)
}
x <- 10
y <- 20
f <- eval(expr(function(x, y) !!x + !!y))
f
f()
attr(f, "srcref") <- NULL
f
# Generate a transient, source-ready R script designed to display x
script_file <- tempfile()
writeLines("print(x)", script_file)
# Define the value of `x` in the global scope
x <- "global scope"
env2 <- env(x = "specified scope")
determine_evaluation <- function(file, local) {
x <- "local scope"
source(file, local = local)
}
# Where will the source() function execute the code?
determine_evaluation(script_file, local = FALSE)  # default behavior
determine_evaluation(script_file, local = env2)
determine_evaluation(script_file, local = TRUE)
# name is a string
get2 <- function(name, env) {}
assign2 <- function(name, value, env) {}
get
get2 <- function(name, env = current_env()) {
sym_name <- sym(name)
eval(sym_name, env)
}
x <- 10
get2("x")
#get2(x)
assign
assign2 <- function(name, value, env = current_env()) {
sym_name <- sym(name)
assign_expr <- expr(!!sym_name <- !!value)
eval(assign_expr, env)
print(x)
}
assign2("x", 6, .GlobalEnv)
x
print(x)
source2 <- function(path, env = caller_env()) {
file <- paste(readLines(path, warn = FALSE), collapse = "\n")
exprs <- parse_exprs(file)
res <- NULL
for (i in seq_along(exprs)) {
res <- eval(exprs[[i]], env)
}
invisible(res)
}
source2 <- function(path, env = caller_env()) {
file <- paste(readLines(path, warn = FALSE), collapse = "\n")
exprs <- parse_exprs(file)
res <- purrr::map(exprs, eval, env)
invisible(res)
}
# tmp_file <- tempfile()
# writeLines(
#   "x <- 1
#    x
#    y <- 2
#    y  # a comment here",
#   tmp_file
# )
#
# (source2(tmp_file))
local3 <- function(expr, envir = new.env()) {
call <- substitute(eval(quote(expr), envir))
eval(call, envir = parent.frame())
}
local3 <- function(expr, envir = new.env()) {
call <- substitute(eval(quote(expr), envir))
print(call)
eval(call, envir = parent.frame())
}
#?substitute
local3({
x <- 10
x * 2
})
eval(quote({
x <- 10
x * 2
}), new.env())
exists("x")
foo <- function(x) enquo(x)
foo(a + b)
quo(x + y + z)
new_quosure(expr(x + y), env(x = 1, y = 10))
q1 <- new_quosure(expr(x + y), env(x = 1, y = 10))
eval_tidy(q1)
f <- function(...) {
x <- 1
g(..., f = x)
}
g <- function(...) {
enquos(...)
}
x <- 0
qs <- f(global = x)
qs
map_dbl(qs, eval_tidy)
f <- ~runif(3)
str(f)
q4 <- new_quosure(expr(x + y + z))
class(q4)
is_call(q4)
q4[[1]]
q4[[2]]
attr(q4, ".Environment")
get_expr(q4)
get_env(q4)
q2 <- new_quosure(expr(x), env(x = 1))
q3 <- new_quosure(expr(x), env(x = 10))
x <- expr(!!q2 + !!q3)
eval_tidy(x)
x
expr_print(x)
q1 <- new_quosure(expr(x), env(x = 1))
q1
q2 <- new_quosure(expr(x + !!q1), env(x = 10))
q2
q3 <- new_quosure(expr(x + !!q2), env(x = 100))
q3
eval_tidy(q1)
eval_tidy(q2)
eval_tidy(q3)
enenv <- function(quos) {
get_env(enquo(quos))
}
# Verify
enenv(x)
# Confirm functionality within functions as well
gather_env <- function(quos) {
enenv(quos)
}
gather_env(x)
tmp_file <- tempfile()
writeLines(
"x <- 1
x
y <- 2
y  # a comment here",
tmp_file
)
#
# (source2(tmp_file))
source2(tmp_file)
tmp_file <- tempfile()
writeLines("x <- 1
x
y <- 2
y  # a comment here",
tmp_file)
source2(tmp_file)
source2 <- function(path, env = caller_env()) {
file <- paste(readLines(path, warn = FALSE), collapse = "\n")
exprs <- parse_exprs(file)
res <- purrr::map(exprs, eval, env)
invisible(res)
}
assign2 <- function(name, value, env = current_env()) {
sym_name <- sym(name)
assign_expr <- expr(!!sym_name <- !!value)
eval(assign_expr, env)
print(x)
}
assign2("x", 6, .GlobalEnv)
x
assign2 <- function(name, value, env = .GlobalEnv) {
sym_name <- sym(name)
assign_expr <- expr(!!sym_name <- !!value)
eval(assign_expr, env)
print(x)
}
assign2("x", 5)
x
source2 <- function(path, env = caller_env()) {
file <- paste(readLines(path, warn = FALSE), collapse = "\n")
exprs <- parse_exprs(file)
res <- purrr::map2(exprs, eval, env)
invisible(res)
}
tmp_file <- tempfile()
writeLines("x <- 1
x
y <- 2
y  # a comment here",
tmp_file)
source2(tmp_file)
source2 <- function(path, env = caller_env()) {
file <- paste(readLines(path, warn = FALSE), collapse = "\n")
exprs <- parse_exprs(file)
res <- purrr::map(exprs, eval, env)
invisible(res)
}
tmp_file <- tempfile()
writeLines("x <- 1
x
y <- 2
y  # a comment here",
tmp_file)
source2(tmp_file)
