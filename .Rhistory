library(MASS)
# fails
MASS
library(MASS)
mtcars2 <- subset(mtcars, cyl == 4)
with(mtcars2, sum(vs))
sum(mtcars2$am)
rm(mtcars2)
library(MASS)
MASS
mtcars2 <- subset(mtcars, cyl == 4)
mtcars2
mtcars
cyl
mtcars2
vs
sum(vs)
rm(mtcars2)
mtcars2
library(dplyr)
library(ggplot2)
by_cyl <- mtcars %>%
group_by(cyl) %>%
summarise(mean = mean(mpg))
ggplot(by_cyl, aes(cyl, mean)) + geom_point()
library(dplyr)
dplyr
by_cyl <- mtcars %>%
group_by(cyl) %>%
summarise(mean = mean(mpg))
mtcars
cyl
mean = mean(mpg)
mpg
mean = mean(mpg)
enexpr
x <- expr(-1)
expr(!!xy / !!yz)
xy <- expr(x + y)
library(rlang)
library(purrr)
x <- expr(-1)
expr(f(!!x, y))
knitr::include_graphics("diagrams/quotation/bang-bang.png")
a <- sym("y")
b <- 1
expr(f(!!a, !!b))
knitr::include_graphics("diagrams/quotation/simple.png")
mean_rm <- function(var) {
var <- ensym(var)
expr(mean(!!var, na.rm = TRUE))
}
expr(!!mean_rm(x) + !!mean_rm(y))
x1 <- expr(x + 1)
x2 <- expr(x + 2)
expr(!!x1 / !!x2)
knitr::include_graphics("diagrams/quotation/infix.png")
knitr::include_graphics("diagrams/quotation/infix-bad.png")
f <- expr(foo)
expr((!!f)(x, y))
f <- expr(pkg::foo)
expr((!!f)(x, y))
knitr::include_graphics("diagrams/quotation/fun.png")
f <- expr(pkg::foo)
call2(f, expr(x), expr(y))
arg <- missing_arg()
expr(foo(!!arg, !!arg))
expr(foo(!!maybe_missing(arg), !!maybe_missing(arg)))
x <- expr(x)
expr(`$`(df, !!x))
xs <- exprs(1, a, -b)
expr(f(!!!xs, y))
# Or with names
ys <- set_names(xs, c("a", "b", "c"))
expr(f(!!!ys, d = 4))
knitr::include_graphics("diagrams/quotation/bang-bang-bang.png")
call2("f", !!!xs, expr(y))
!!TRUE
!!!TRUE
x <- quote(variable)
!!x
df <- data.frame(x = 1:5)
y <- 100
with(df, x + !!y)
x1 <- expr(class(!!data.frame(x = 10)))
x1
eval(x1)
expr_print(x1)
lobstr::ast(!!x1)
x2 <- expr(f(!!c(1L, 2L, 3L, 4L, 5L)))
x2
expr_print(x2)
lobstr::ast(!!x2)
x3 <- expr(1 + !!expr(2 + 3))
x3
lobstr::ast(!!x3)
xy <- expr(x + y)
xz <- expr(x + z)
yz <- expr(y + z)
abc <- exprs(a, b, c)
expr(!!xy / !!yz)
(a <- expr(mean(1:10)))
(b <- expr(mean(!!(1:10))))
identical(a, b)
xyz <- bquote((x + y + z))
bquote(-.(xyz) / 2)
x <- list(var = 1, y = 2)
var <- "y"
x$var
x[[var]]
x <- 1
rm(x)
y <- 2
vars <- c("y", "vars")
rm(list = vars)
library(MASS)
pkg <- "MASS"
library(pkg, character.only = TRUE)
palette(RColorBrewer::brewer.pal(3, "Set1"))
plot(
Sepal.Length ~ Petal.Length,
data = iris,
col = Species,
pch = 20,
cex = 2
)
dfs <- list(
a = data.frame(x = 1, y = 2),
b = data.frame(x = 3, y = 4)
)
var <- "x"
val <- c(4, 3, 9)
dplyr::bind_rows(!!!dfs)
tibble::tibble(!!var := val)
set_attr <- function(.x, ...) {
attr <- rlang::list2(...)
attributes(.x) <- attr
.x
}
attrs <- list(x = 1, y = 2)
attr_name <- "z"
1:10 %>%
set_attr(w = 0, !!!attrs, !!attr_name := 3) %>%
str()
# Directly
exec("mean", x = 1:10, na.rm = TRUE, trim = 0.1)
# Indirectly
args <- list(x = 1:10, na.rm = TRUE, trim = 0.1)
exec("mean", !!!args)
# Mixed
params <- list(na.rm = TRUE, trim = 0.1)
exec("mean", x = 1:10, !!!params)
arg_name <- "na.rm"
arg_val <- TRUE
exec("mean", 1:10, !!arg_name := arg_val)
x <- c(runif(10), NA)
funs <- c("mean", "median", "sd")
purrr::map_dbl(funs, exec, x, na.rm = TRUE)
# Can easily move x to first entry:
tibble::tibble(
y = 1:5,
z = 3:-1,
x = 5:1,
)
# Need to remove comma from z and add comma to x
data.frame(
y = 1:5,
z = 3:-1,
x = 5:1
)
str(dots_list(x = 1, x = 2))
str(dots_list(x = 1, x = 2, .homonyms = "first"))
str(dots_list(x = 1, x = 2, .homonyms = "last"))
str(dots_list(x = 1, x = 2, .homonyms = "error"))
do.call("rbind", dfs)
args <- list(val)
names(args) <- var
do.call("data.frame", args)
f <- function(...) {
dots <- list(...)
if (length(dots) == 1 && is.list(dots[[1]])) {
dots <- dots[[1]]
}
# Do something
...
}
f <- function(..., .dots) {
dots <- c(list(...), .dots)
# Do something
}
exec <- function(f, ..., .env = caller_env()) {
args <- list2(...)
do.call(f, args, envir = .env)
}
set_attr <- function(x, ...) {
attr <- rlang::list2(...)
attributes(x) <- attr
x
}
set_attr(1:10, x = 10)
z <- expr(foo(x, y))
lobstr::ast(z)
lobstr::ast(!!z)
intercept <- 10
coefs <- c(x1 = 5, x2 = -4)
coef_sym <- syms(names(coefs))
coef_sym
summands <- map2(coef_sym, coefs, ~ expr((!!.x * !!.y)))
summands
summands <- c(intercept, summands)
summands
eq <- reduce(summands, ~ expr(!!.x + !!.y))
eq
var <- expr(y)
coef_sym <- map(seq_along(coefs), ~ expr((!!var)[[!!.x]]))
coef_sym
linear <- function(var, val) {
var <- ensym(var)
coef_name <- map(seq_along(val[-1]), ~ expr((!!var)[[!!.x]]))
summands <- map2(val[-1], coef_name, ~ expr((!!.x * !!.y)))
summands <- c(val[[1]], summands)
reduce(summands, ~ expr(!!.x + !!.y))
}
linear(x, c(10, 5, -4))
indices <- rep(list(missing_arg()), 3)
expr(x[!!!indices])
indices[[2]] <- 1
expr(x[!!!indices])
slice <- function(x, along, index) {
stopifnot(length(along) == 1)
stopifnot(length(index) == 1)
nd <- length(dim(x))
indices <- rep(list(missing_arg()), nd)
indices[[along]] <- index
expr(x[!!!indices])
}
x <- array(sample(30), c(5, 2, 3))
slice(x, 1, 3)
slice(x, 2, 2)
slice(x, 3, 1)
new_function(
exprs(x = , y = ),
expr({x + y})
)
power <- function(exponent) {
new_function(
exprs(x = ),
expr({
x ^ !!exponent
}),
caller_env()
)
}
power(0.5)
curve(sin(exp(4 * x)), n = 1000)
curve2 <- function(expr, xlim = c(0, 1), n = 100) {
expr <- enexpr(expr)
f <- new_function(exprs(x = ), expr)
x <- seq(xlim[1], xlim[2], length = n)
y <- f(x)
plot(x, y, type = "l", ylab = expr_text(expr))
}
curve2(sin(exp(4 * x)), n = 1000)
bc <- function(lambda) {
if (lambda == 0) {
function(x) log(x)
} else {
function(x) (x ^ lambda - 1) / lambda
}
}
compose <- function(f, g) {
function(...) f(g(...))
}
xy/yz
!!xy / !!yz
expr(xy / yz)
-expr(!!xz ^ !!yz)
-expr((!!xz) ^ (!!yz))
expr((!!xz) ^ (!!yz))
expr(-(!!xz) ^ (!!yz))
expr(!!xy + !! yz - !!xy)
expr((!!xy) + !! yz - !!xy)
expr((!!xy) + !! yz - !!xy)
expr(((!!xy)) + !! yz - !!xy)
expr(((!!xy)) + !!yz - !!xy)
expr(!!xy + !! yz - !!xy)
expr(((!!xy)) + !!yz - !!xy)
expr(atan2(!!xy, !!yz))
expr(sum(!!xy, !!xy, !!yz))
expr(sum(!!abc))
expr(sum(!!!abc))
expr(mean(!!!abc, na.rm = TRUE))
expr(mean(c(!!!abc), na.rm = TRUE))
expr(foo(a = x + y, b = y + z))
expr(foo(a = !!xy, b = !!yz))
(a <- expr(mean(1:10)))
(b <- expr(mean(!!(1:10))))
identical(a, b)
lobstr::ast(mean(1:10))
lobstr::ast(mean(!!(1:10)))
(a <- expr(mean(1:10)))
(b <- expr(mean(!!(1:10))))
identical(a, b)
xyz <- bquote((x + y + z))
bquote(-.(xyz) / 2)
call <- names(pryr::find_uses("package:base", "match.call"))
subs <- names(pryr::find_uses("package:base", "substitute"))
eval <- names(pryr::find_uses("package:base", "eval"))
intersect(subs, eval)
x <- list(var = 1, y = 2)
var <- "y"
x$var
x[[var]]
x <- 1
rm(x)
y <- 2
vars <- c("y", "vars")
rm(list = vars)
rm(x)
x <- 1
rm(x)
y <- 2
vars <- c("y", "vars")
rm(list = vars)
library(MASS)
pkg <- "MASS"
library(pkg, character.only = TRUE)
library(MASS)
pkg <- "MASS"
library(pkg, character.only = TRUE)
# Shows help for var
help(var)
var <- "mean"
# Shows help for mean
help(var)
var <- 10
# Shows help for var
help(var)
var <- "mean"
# Shows help for mean
help(var)
# Shows help for var
help(var)
var <- "mean"
# Shows help for mean
help(var)
var <- 10
# Shows help for var
help(var)
palette(RColorBrewer::brewer.pal(3, "Set1"))
plot(
Sepal.Length ~ Petal.Length,
data = iris,
col = Species,
pch = 20,
cex = 2
)
dfs <- list(
a = data.frame(x = 1, y = 2),
b = data.frame(x = 3, y = 4)
)
dfs
var <- "x"
val <- c(4, 3, 9)
dplyr::bind_rows(!!!dfs)
dplyr::bind_rows(!!!dfs)
tibble::tibble(!!var := val)
tibble::tibble(!!var := val)
dplyr::bind_rows(!!!dfs)
tibble::tibble(!!var := val)
str(dots_list(x = 1, x = 2))
str(dots_list(x = 1, x = 2, .homonyms = "first"))
str(dots_list(x = 1, x = 2, .homonyms = "last"))
str(dots_list(x = 1, x = 2, .homonyms = "error"))
interaction()
interaction
expand.grid
par
set_attr <- function(x, ...) {
attr <- rlang::list2(...)
attributes(x) <- attr
x
}
set_attr(1:10, x = 10)
set_attr <- function(.x, ...) {
attr <- rlang::list2(...)
attributes(.x) <- attr
.x
}
set_attr(1:10, x = 10)
intercept <- 10
coefs <- c(x1 = 5, x2 = -4)
coef_sym <- syms(names(coefs))
coef_sym
summands <- map2(coef_sym, coefs, ~ expr((!!.x * !!.y)))
summands
summands <- c(intercept, summands)
summands
eq <- reduce(summands, ~ expr(!!.x + !!.y))
eq
var <- expr(y)
coef_sym <- map(seq_along(coefs), ~ expr((!!var)[[!!.x]]))
coef_sym
!!var
var
.x
var <- expr(y)
coef_sym <- map(seq_along(coefs), ~ expr((!!var)[[!!.x]]))
coef_sym
coefs
var <- expr(y)
coef_sym <- map(seq_along(coefs), ~ expr((!!var)[[!!.x]]))
coef_sym
linear <- function(var, val) {
var <- ensym(var)
coef_name <- map(seq_along(val[-1]), ~ expr((!!var)[[!!.x]]))
summands <- map2(val[-1], coef_name, ~ expr((!!.x * !!.y)))
summands <- c(val[[1]], summands)
reduce(summands, ~ expr(!!.x + !!.y))
}
linear(x, c(10, 5, -4))
expr((!!var)[[!!.x]]))
expr((!!var)[[!!.x]])
var <- expr(y)
coef_sym <- map(seq_along(coefs), ~ expr((!!var)[[!!.x]]))
coef_sym
reduce(summands, ~ expr(!!.x + !!.y))
reduce(summands, call2, "+")
reduce(summands, rlang::call2, "+")
summands
reduce(summands, ~ call2, "+")
reduce(summands, ~ call2, "+")
reduce(summands, ~ expr(!!.x + !!.y))
reduce(summands, expr(call2), "+")
reduce(summands, call2, "+")
# Define a function factory for Box-Cox transformations
box_cox_factory <- function(lambda) {
lambda <- enexpr(lambda)
if (!!lambda == 0) {
new_function(exprs(x = ), expr(log(x)))
} else {
new_function(exprs(x = ), expr((x ^ (!!lambda) - 1) / !!lambda))
}
}
# Example usage
box_cox_0 <- box_cox_factory(0)
box_cox_2 <- box_cox_factory(2)
result <- box_cox_2(2)
# Example usage
box_cox_0 <- box_cox_factory(0)
box_cox_2 <- box_cox_factory(2)
box_cox_0
box_cox_2
box_cox_2
result
library(rlang)
bc2 <- function(lambda) {
lambda <- enexpr(lambda)
if (!!lambda == 0) {
new_function(exprs(x = ), expr(log(x)))
} else {
new_function(exprs(x = ), expr((x ^ (!!lambda) - 1) / !!lambda))
}
}
bc2(0)
bc2(2)
bc2(2)(2)
# Define a function to compose two functions
compose2_functions <- function(f, g) {
f <- enexpr(f)
g <- enexpr(g)
new_function(exprs(... = ), expr((!!f)((!!g)(...))))
}
# Example usage with built-in functions
composed_function1 <- compose2_functions(sin, cos)
result1 <- composed_function1(pi)
# Example usage with user-defined functions
composed_function2 <- compose2_functions(sin, cos)
result2 <- composed_function2(pi)
compose <- function(f, g) {
function(...) f(g(...))
}
composed_function1
result1
# Example usage with user-defined functions
composed_function2 <- compose2_functions(sin, cos)
composed_function2
result2 <- composed_function2(pi)
result2
# Define a function to compose two functions
compose2_functions <- function(f, g) {
f <- enexpr(f)
g <- enexpr(g)
new_function(exprs(... = ), expr((!!f)((!!g)(...))))
}
# Example usage with built-in functions
composed_function1 <- compose2_functions(sin, cos)
composed_function1
result1 <- composed_function1(pi)
result1
# Example usage with user-defined functions
composed_function2 <- compose2_functions(sin, cos)
composed_function2
result2 <- composed_function2(pi)
result2
reduce(summands, call2, .fn = "+")
reduce(summands, call2, .f = "+")
reduce(summands, call2, .fn = "+")
box_cox_factory(2)
wtf <- compose(abs, sum)
wtf(c(1,3,5,6))
wtf(c(1,3,5,6,-20))
