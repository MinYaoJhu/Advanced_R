if (length(x) == 1L & is.null(default) == TRUE)
return(x)
if (length(x) == 1L & is.null(default) == FALSE)
out <- f(default, x)
return(out)
out <- x[[1]]
for (i in seq(2, length(x))) {
out <- f(out, x[[i]])
}
out
}
simple_reduce(c(1:5), sum)
simple_reduce(c(1:5), sum, 1)
simple_reduce(1, sum)
simple_reduce(1, sum)
simple_reduce(1, sum, 1)
simple_reduce(1, sum, 1)
simple_reduce(integer(), sum, 1)
simple_reduce(integer(), sum)
span
span()
rle()
?rle()
x <- rev(rep(6:10, 1:5))
str(x)
rle(x)
x
x <- rev(rep(6:10, 1:5))
str(x)
x
span <- function(x, f) {
idx <- unname(map_lgl(x, ~ f(.x)))
rle <- rle(idx)
# # Check if the predicate is never true
# if (!any(rle$values)) {
#   return(integer(0))
# }
#
# # Find the length of the longest sequence of true values
# longest <- max(rle$lengths[rle$values])
# # Find the positition of the (first) longest run in rle
# longest_idx <- which(rle$values & rle$lengths == longest)[1]
#
# # Add up all lengths in rle before the longest run
# ind_before_longest <- sum(rle$lengths[seq_len(longest_idx - 1)])
#
# out_start <- ind_before_longest + 1L
# out_end <- ind_before_longest + longest
# out_start:out_end
}
# Check that it works
span(c(0,  0,  0,  0,  0), is.na)
#> integer(0)
span(c(NA, 0,  0,  0,  0), is.na)
#> [1] 1
span(c(NA, 0, NA, NA, NA), is.na)
col3 <- 750+ 100*rt(1500, df = 3)
breaks <- factor(cut(col3, breaks = 360+5*(0:155)))
z <- table(breaks)
z[1:5] # The names are larger than the data ...
barplot(unname(z), axes = FALSE)
unname(z)
z <- table(breaks)
z[1:5] # The names are larger than the data ...
str(unname(z))
span <- function(x, f) {
idx <- unname(map_lgl(x, ~ f(.x)))
rle <- rle(idx)
# Check if the predicate is never true
if (!any(rle$values)) {
return(integer(0))
}
# Find the length of the longest sequence of true values
longest <- max(rle$lengths[rle$values])
# Find the positition of the (first) longest run in rle
longest_idx <- which(rle$values & rle$lengths == longest)[1]
# Add up all lengths in rle before the longest run
ind_before_longest <- sum(rle$lengths[seq_len(longest_idx - 1)])
out_start <- ind_before_longest + 1L
out_end <- ind_before_longest + longest
out_start:out_end
}
# Check that it works
span(c(0,  0,  0,  0,  0), is.na)
#> integer(0)
span(c(NA, 0,  0,  0,  0), is.na)
#> [1] 1
span(c(NA, 0, NA, NA, NA), is.na)
#> [1] 3 4 5
z <- c(TRUE, TRUE, FALSE, FALSE, TRUE, FALSE, TRUE, TRUE, TRUE)
rle(z)
span <- function(x, f) {
idx <- unname(map_lgl(x, ~ f(.x)))
rle <- rle(idx)
# Check if the predicate is never true
if (none(rle$values,is_true)) {
return(integer(0))
}
# Find the length of the longest sequence of true values
longest <- max(rle$lengths[rle$values])
# Find the positition of the (first) longest run in rle
longest_idx <- which(rle$values & rle$lengths == longest)[1]
# Add up all lengths in rle before the longest run
ind_before_longest <- sum(rle$lengths[seq_len(longest_idx - 1)])
out_start <- ind_before_longest + 1L
out_end <- ind_before_longest + longest
out_start:out_end
}
# Check that it works
span(c(0,  0,  0,  0,  0), is.na)
library(rlang)
span <- function(x, f) {
idx <- unname(map_lgl(x, ~ f(.x)))
rle <- rle(idx)
# Check if the predicate is never true
if (none(rle$values,is_true)) {
return(integer(0))
}
# Find the length of the longest sequence of true values
longest <- max(rle$lengths[rle$values])
# Find the positition of the (first) longest run in rle
longest_idx <- which(rle$values & rle$lengths == longest)[1]
# Add up all lengths in rle before the longest run
ind_before_longest <- sum(rle$lengths[seq_len(longest_idx - 1)])
out_start <- ind_before_longest + 1L
out_end <- ind_before_longest + longest
out_start:out_end
}
# Check that it works
span(c(0,  0,  0,  0,  0), is.na)
#> integer(0)
span(c(NA, 0,  0,  0,  0), is.na)
#> [1] 1
span(c(NA, 0, NA, NA, NA), is.na)
#> [1] 3 4 5
span <- function(x, f) {
idx <- unname(map_lgl(x, ~ f(.x)))
rle <- rle(idx)
# Check if the predicate is never true
if (none(rle$values,is_true)) {
#return(integer(0))
stop("the predicate is never true")
}
# Find the length of the longest sequence of true values
longest <- max(rle$lengths[rle$values])
# Find the positition of the (first) longest run in rle
longest_idx <- which(rle$values & rle$lengths == longest)[1]
# Add up all lengths in rle before the longest run
ind_before_longest <- sum(rle$lengths[seq_len(longest_idx - 1)])
out_start <- ind_before_longest + 1L
out_end <- ind_before_longest + longest
out_start:out_end
}
# Check that it works
span(c(0,  0,  0,  0,  0), is.na)
# Check that it works
span(c(0,  0,  0,  0,  0), is.na)
#> integer(0)
span(c(NA, 0,  0,  0,  0), is.na)
#> [1] 1
span(c(NA, 0, NA, NA, NA), is.na)
x <- c(1:4, 0:5, 11)
x
which.max(x)
x <- c(11,1:4, 0:5)
x
which.max(x)
x <- c(11, 1:4, 0:5)
x
which.max(x)
scale01 <- function(x) {
rng <- range(x, na.rm = TRUE)
(x - rng[1]) / (rng[2] - rng[1])
}
library(rlang)
library(ggplot2)
library(scales)
power1 <- function(exp) {
function(x) {
x ^ exp
}
}
square <- power1(2)
cube <- power1(3)
square(3)
cube(3)
library(rlang)
library(ggplot2)
library(scales)
power1 <- function(exp) {
function(x) {
x ^ exp
}
}
square <- power1(2)
cube <- power1(3)
square(3)
cube(3)
library(rlang)
library(ggplot2)
library(scales)
square
cube
env_print(square)
env_print(cube)
fn_env(square)$exp
fn_env(cube)$exp
knitr::include_graphics("diagrams/function-factories/power-full.png")
knitr::include_graphics("diagrams/function-factories/power-simple.png")
square(10)
knitr::include_graphics("diagrams/function-factories/power-exec.png")
x <- 2
square <- power1(x)
x <- 3
square(2)
power2 <- function(exp) {
force(exp)
function(x) {
x ^ exp
}
}
x <- 2
square <- power2(x)
x <- 3
square(2)
new_counter <- function() {
i <- 0
function() {
i <<- i + 1
i
}
}
counter_one <- new_counter()
counter_two <- new_counter()
knitr::include_graphics("diagrams/function-factories/counter-1.png")
counter_one()
counter_one()
counter_two()
knitr::include_graphics("diagrams/function-factories/counter-2.png")
f1 <- function(n) {
x <- runif(n)
m <- mean(x)
function() m
}
g1 <- f1(1e6)
lobstr::obj_size(g1)
f2 <- function(n) {
x <- runif(n)
m <- mean(x)
rm(x)
function() m
}
g2 <- f2(1e6)
lobstr::obj_size(g2)
force
i <- 0
new_counter2 <- function() {
i <<- i + 1
i
}
new_counter3 <- function() {
i <- 0
function() {
i <- i + 1
i
}
}
y <- c(12345, 123456, 1234567)
comma_format()(y)
number_format(scale = 1e-3, suffix = " K")(y)
df <- data.frame(x = 1, y = y)
core <- ggplot(df, aes(x, y)) +
geom_point() +
scale_x_continuous(breaks = 1, labels = NULL) +
labs(x = NULL, y = NULL)
core
core + scale_y_continuous(
labels = comma_format()
)
core + scale_y_continuous(
labels = number_format(scale = 1e-3, suffix = " K")
)
core + scale_y_continuous(
labels = scientific_format()
)
# construct some sample data with very different numbers in each cell
sd <- c(1, 5, 15)
n <- 100
df <- data.frame(x = rnorm(3 * n, sd = sd), sd = rep(sd, n))
ggplot(df, aes(x)) +
geom_histogram(binwidth = 2) +
facet_wrap(~ sd, scales = "free_x") +
labs(x = NULL)
binwidth_bins <- function(n) {
force(n)
function(x) {
(max(x) - min(x)) / n
}
}
ggplot(df, aes(x)) +
geom_histogram(binwidth = binwidth_bins(20)) +
facet_wrap(~ sd, scales = "free_x") +
labs(x = NULL)
base_bins <- function(type) {
fun <- switch(type,
Sturges = nclass.Sturges,
scott = nclass.scott,
FD = nclass.FD,
stop("Unknown type", call. = FALSE)
)
function(x) {
(max(x) - min(x)) / fun(x)
}
}
ggplot(df, aes(x)) +
geom_histogram(binwidth = base_bins("FD")) +
facet_wrap(~ sd, scales = "free_x") +
labs(x = NULL)
plot_dev <- function(ext, dpi = 96) {
force(dpi)
switch(ext,
eps =  ,
ps  =  function(path, ...) {
grDevices::postscript(
file = filename, ..., onefile = FALSE,
horizontal = FALSE, paper = "special"
)
},
pdf = function(filename, ...) grDevices::pdf(file = filename, ...),
svg = function(filename, ...) svglite::svglite(file = filename, ...),
emf = ,
wmf = function(...) grDevices::win.metafile(...),
png = function(...) grDevices::png(..., res = dpi, units = "in"),
jpg = ,
jpeg = function(...) grDevices::jpeg(..., res = dpi, units = "in"),
bmp = function(...) grDevices::bmp(..., res = dpi, units = "in"),
tiff = function(...) grDevices::tiff(..., res = dpi, units = "in"),
stop("Unknown graphics extension: ", ext, call. = FALSE)
)
}
plot_dev("pdf")
plot_dev("png")
?approxfun
x <- runif(10)
y <- runif(10)
plot(x, y, lwd = 10)
f_lin <- approxfun(x, y)
f_con <- approxfun(x, y, method = "constant")
# Both functions exactly reproduce their input y values
identical(f_lin(x), y)
#> [1] TRUE
identical(f_con(x), y)
x <- 1:10
y <- rnorm(10)
par(mfrow = c(2,1))
plot(x, y, main = "approx(.) and approxfun(.)")
x <- 1:10
y <- rnorm(10)
par(mfrow = c(2,1))
plot(x, y, main = "approx(.) and approxfun(.)")
points(approx(x, y), col = 2, pch = "*")
points(approx(x, y, method = "constant"), col = 4, pch = "*")
f <- approxfun(x, y)
curve(f(x), 0, 11, col = "green2")
points(x, y)
is.function(fc <- approxfun(x, y, method = "const")) # TRUE
curve(fc(x), 0, 10, col = "darkblue", add = TRUE)
## different extrapolation on left and right side :
plot(approxfun(x, y, rule = 2:1), 0, 11,
col = "tomato", add = TRUE, lty = 3, lwd = 2)
x <- 1:10
y <- rnorm(10)
par(mfrow = c(2,1))
plot(x, y, main = "approx(.) and approxfun(.)")
points(approx(x, y), col = 2, pch = "*")
points(approx(x, y, method = "constant"), col = 4, pch = "*")
x <- 1:10
y <- rnorm(10)
par(mfrow = c(2,1))
plot(x, y, main = "approx(.) and approxfun(.)")
points(approx(x, y), col = 2, pch = "*")
points(approx(x, y, method = "constant"), col = 4, pch = "*")
f <- approxfun(x, y)
curve(f(x), 0, 11, col = "green2")
points(x, y)
is.function(fc <- approxfun(x, y, method = "const")) # TRUE
curve(fc(x), 0, 10, col = "darkblue", add = TRUE)
## different extrapolation on left and right side :
plot(approxfun(x, y, rule = 2:1), 0, 11,
col = "tomato", add = TRUE, lty = 3, lwd = 2)
x <- 1:10
y <- rnorm(10)
par(mfrow = c(2,1))
plot(x, y, main = "approx(.) and approxfun(.)")
points(approx(x, y), col = 2, pch = "*")
points(approx(x, y, method = "constant"), col = 4, pch = "*")
f <- approxfun(x, y)
curve(f(x), 0, 11, col = "green2")
points(x, y)
is.function(fc <- approxfun(x, y, method = "const")) # TRUE
curve(fc(x), 0, 10, col = "darkblue", add = TRUE)
## different extrapolation on left and right side :
plot(approxfun(x, y, rule = 2:1), 0, 11,
col = "tomato", add = TRUE, lty = 3, lwd = 2)
x <- 1:10
y <- rnorm(10)
par(mfrow = c(2,1))
plot(x, y, main = "approx(.) and approxfun(.)")
points(approx(x, y), col = 2, pch = "*")
points(approx(x, y, method = "constant"), col = 4, pch = "*")
f <- approxfun(x, y)
curve(f(x), 0, 11, col = "green2")
points(x, y)
is.function(fc <- approxfun(x, y, method = "const")) # TRUE
curve(fc(x), 0, 10, col = "darkblue", add = TRUE)
## different extrapolation on left and right side :
plot(approxfun(x, y, rule = 2:1), 0, 11,
col = "tomato", add = TRUE, lty = 3, lwd = 2)
pick(1)(x)
pick <- function(i) {
force(i)
function(x) x[[i]]
}
x <- 1:3
identical(x[[1]], pick(1)(x))
identical(
lapply(mtcars, function(x) x[[5]]),
lapply(mtcars, pick(5))
)
pick(5)
m1 <- moment(1)
i <- 0
new_counter2 <- function() {
i <<- i + 1
i
}
new_counter2()
i
new_counter2()
i
i <- 5
new_counter2()
i
new_counter3 <- function() {
i <- 0
function() {
i <- i + 1
i
}
}
new_counter3()
i
new_counter_3 <- new_counter3()
new_counter_3()
i
new_counter_3 <- new_counter3()
new_counter_3()
new_counter_3()
?ggplot2::label_bquote()
?scales::number_format()
library(rlang)
library(ggplot2)
library(scales)
?ggplot2::label_bquote()
# The variables mentioned in the plotmath expression must be
# backquoted and referred to by their names.
p <- ggplot(mtcars, aes(wt, mpg)) + geom_point()
p + facet_grid(vs ~ ., labeller = label_bquote(alpha ^ .(vs)))
p + facet_grid(. ~ vs, labeller = label_bquote(cols = .(vs) ^ .(vs)))
p + facet_grid(. ~ vs + am, labeller = label_bquote(cols = .(am) ^ .(vs)))
?scales::number_format()
m1 <- moment(1)
moment <- function(i) {
force(i)
function(x) sum((x - mean(x)) ^ i) / length(x)
}
m1 <- moment(1)
m2 <- moment(2)
m1
x <- runif(100)
all.equal(m1(x), 0)
all.equal(m2(x), var(x) * 99 / 100)
?ecdf()
##-- Simple didactical  ecdf  example :
x <- rnorm(12)
Fn <- ecdf(x)
Fn     # a *function*
Fn(x)  # returns the percentiles for x
tt <- seq(-2, 2, by = 0.1)
12 * Fn(tt) # Fn is a 'simple' function {with values k/12}
summary(Fn)
##--> see below for graphics
knots(Fn)  # the unique data values {12 of them if there were no ties}
##-- Simple didactical  ecdf  example :
x <- rnorm(12)
Fn <- ecdf(x)
Fn     # a *function*
Fn(x)  # returns the percentiles for x
tt <- seq(-2, 2, by = 0.1)
12 * Fn(tt) # Fn is a 'simple' function {with values k/12}
summary(Fn)
##--> see below for graphics
knots(Fn)  # the unique data values {12 of them if there were no ties}
m1 <- moment(1)
m2 <- moment(2)
x <- runif(100)
all.equal(m1(x), 0)
all.equal(m2(x), var(x) * 99 / 100)
stopifnot(all.equal(m1(x), 0))
stopifnot(all.equal(m2(x), var(x) * 99 / 100))
stopifnot(all.equal(m1(x), 0))
stopifnot(all.equal(m2(x), var(x) * 99 / 100))
