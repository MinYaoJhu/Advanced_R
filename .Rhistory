f1 <- function(x1) {
f2 <- function(x2) {
f3 <- function(x3) {
x1 + x2 + x3
}
f3(3)
env_print()
}
f2(2)
env_print()
}
f1(1)
env_print()
knitr::include_graphics("diagrams/environments/Advanced_R_7.4.5_Exercises.png")
#?str
fget <- function(name, env = caller_env()) {
# Base case
if (identical(env, emptyenv())) {
stop("Could not find a function called ", name, ".", call. = FALSE)
}
# Success case
else{
if (env_has(env, name)) {
obj <- env_get(env, name)
if (is.function(obj)) {
return(list(fun = obj, env = env))
}
}
}
# Recursive anyway
fget(name, env_parent(env))
}
fstr <- function(fun_name, env = caller_env()) {
if (!is.character(fun_name)) {
stop("`fun_name` should be a string.", call. = FALSE)
}
fun_env <- fget(fun_name, env)
list(
environment = fun_env$env,
namespace = fn_env(fun_env$fun)
)
}
# Test
fstr("mean")
fstr("str")
f <- function(x) {
g(x = 2)
}
g <- function(x) {
h(x = 3)
}
h <- function(x) {
stop()
}
knitr::include_graphics("diagrams/environments/calling.png")
ls
ls()
env_names(current_env())
new_ls <- function(env = caller_env()) {
sort(env_names(env))
}
ls(all.names = TRUE)
new_ls()
#test
ls(e)
new_ls(e)
my_env <- new.env(parent = emptyenv())
my_env$a <- 1
get_a <- function() {
my_env$a
}
set_a <- function(value) {
old <- my_env$a
my_env$a <- value
invisible(old)
}
View(ls)
new_ls <- function(env = caller_env()) {
sort(env_names(env))
}
ls(all.names = TRUE)
new_ls()
#test
ls(e)
new_ls(e)
View(f)
f <- function(x) {
g(x = 2)
}
g <- function(x) {
h(x = 3)
}
h <- function(x) {
stop()
}
# f calls g, which calls h, which calls stop.
f <- function(x) {
g(x = 2)
}
g <- function(x) {
h(x = 3)
}
h <- function(x) {
stop()
}
f(x = 1)
#> Error:
traceback()
h <- function(x) {
lobstr::cst()
}
f(x = 1)
#> █
#> └─f(x = 1)
#>   └─g(x = 2)
#>     └─h(x = 3)
#>       └─lobstr::cst()
f
library(sloop)
f <- factor(c("a", "b", "c"))
typeof(f)
attributes(f)
unclass(f)
ftype(print)
ftype(str)
ftype(unclass)
print(f)
# stripping class reverts to integer behaviour
print(unclass(f))
time <- strptime(c("2017-01-01", "2020-05-04 03:21"), "%Y-%m-%d")
str(time)
str(unclass(time))
s3_dispatch(print(f))
ftype(t.test)
ftype(t.data.frame)
weighted.mean.Date
s3_get_method(weighted.mean.Date)
ftype(t.test)
ftype(t.data.frame)
library(rlist)
objs <- mget(ls("package:base", all = TRUE), inherits = TRUE)
funs <- Filter(is.function, objs)
funs_df <- as.list(funs)
head(funs_df)
str(funs_df)
funs_df_name <- as.data.frame(names(funs_df))
funs_df_name$names <- funs_df_name[[1]]
str(funs_df_name)
funs_df_filtered <- dplyr::filter(funs_df_name, grepl('.',names))
funs_df_filtered
# Some base R functions with point.separated names
install.packages
read.csv
list.files
download.file
data.frame
as.character
Sys.Date
all.equal
do.call
on.exit
set.seed(1014)
some_days <- as.Date("2017-01-31") + sample(10, 5)
mean(some_days)
mean(unclass(some_days))
ftype(mean)
class(some_days)
class(unclass(some_days))
x <- ecdf(rpois(100, 10))
x
class(x)
typeof(x)
attributes(x)
x <- table(rpois(100, 5))
x
class(x)
typeof(x)
attributes(x)
# Create and assign class in one step
x <- structure(list(), class = "my_class")
# Create, then set class
x <- list()
class(x) <- "my_class"
class(x)
inherits(x, "my_class")
inherits(x, "your_class")
# Create a linear model
mod <- lm(log(mpg) ~ log(disp), data = mtcars)
class(mod)
print(mod)
# Turn it into a date (?!)
class(mod) <- "Date"
# Unsurprisingly this doesn't work very well
print(mod)
new_Date <- function(x = double()) {
stopifnot(is.double(x))
structure(x, class = "Date")
}
new_Date(c(-1, 0, 1))
new_difftime <- function(x = double(), units = "secs") {
stopifnot(is.double(x))
units <- match.arg(units, c("secs", "mins", "hours", "days", "weeks"))
structure(x,
class = "difftime",
units = units
)
}
new_difftime(c(1, 10, 3600), "secs")
new_difftime(52, "weeks")
new_factor <- function(x = integer(), levels = character()) {
stopifnot(is.integer(x))
stopifnot(is.character(levels))
structure(
x,
levels = levels,
class = "factor"
)
}
new_factor(1:5, "a")
new_factor(0:1, "a")
validate_factor <- function(x) {
values <- unclass(x)
levels <- attr(x, "levels")
if (!all(!is.na(values) & values > 0)) {
stop(
"All `x` values must be non-missing and greater than zero",
call. = FALSE
)
}
if (length(levels) < max(values)) {
stop(
"There must be at least as many `levels` as possible values in `x`",
call. = FALSE
)
}
x
}
validate_factor(new_factor(1:5, "a"))
validate_factor(new_factor(0:1, "a"))
new_difftime(1:10)
difftime <- function(x = double(), units = "secs") {
x <- as.double(x)
new_difftime(x, units = units)
}
difftime(1:10)
factor <- function(x = character(), levels = unique(x)) {
ind <- match(x, levels)
validate_factor(new_factor(ind, levels))
}
factor(c("a", "a", "b"))
POSIXct <- function(year = integer(),
month = integer(),
day = integer(),
hour = 0L,
minute = 0L,
sec = 0,
tzone = "") {
ISOdatetime(year, month, day, hour, minute, sec, tz = tzone)
}
POSIXct(2020, 1, 1, tzone = "America/New_York")
typeof(funs_df_filtered)
attributes(funs_df_filtered)
class(funs_df_filtered)
new_data.frame <- function(x, n, row.names = NULL) {
# Check if the underlying object is a list
stopifnot(is.list(x))
# Check all inputs are the same length
# (This check also allows that x has length 0)
stopifnot(all(lengths(x) == n))
if (is.null(row.names)) {
# Use special row names helper from base R
# .set_row_names(n) generates that form for automatic row names
# of length n, to be assigned to attr(<a data frame>, "row.names").
row.names <- .set_row_names(n)
} else {
# Otherwise check that they're a character vector with the correct length
stopifnot(is.character(row.names), length(row.names) == n)
}
structure(
x,
class = "data.frame",
row.names = row.names
)
}
# Test
x <- list(a = 1, b = 2)
x
new_data.frame(x, n = 1)
new_data.frame(x, n = 1, row.names = "l1")
# Create a data frame with 0 columns and 2 rows
new_data.frame(list(), n = 2)
#> data frame with 0 columns and 2 rows
factor
base::factor(c("a", "b", "c"), levels = c("a", "b"))
new_factor <- function(x = integer(), levels = character()) {
stopifnot(is.integer(x))
stopifnot(is.character(levels))
structure(
x,
levels = levels,
class = "factor"
)
}
validate_factor <- function(x) {
values <- unclass(x)
levels <- attr(x, "levels")
if (!all(!is.na(values) & values > 0)) {
stop(
"All `x` values must be non-missing and greater than zero",
call. = FALSE
)
}
if (length(levels) < max(values)) {
stop(
"There must be at least as many `levels` as possible values in `x`",
call. = FALSE
)
}
x
}
factor <- function(x = character(), levels = unique(x)) {
ind <- match(x, levels)
validate_factor(new_factor(ind, levels))
}
# The levels argument is optional.
# If it's not provided, the function will use the unique values of x as the levels.
factor2 <- function(x, levels = unique(x)) {
# uses match() to create a new factor with the same levels as x,
# but with the values in the order of the levels argument.
new_levels <- match(x, levels)
# Error if levels don't include all values
# uses setdiff() to find any values in x that are not in the levels argument.
missing <- unique(setdiff(x, levels))
# If there are any missing values, the function stops with an error message.
if (length(missing) > 0) {
stop(
"The following values do not occur in the levels of x: ",
paste0("'", missing, "'", collapse = ", "), ".",
call. = FALSE
)
}
# uses validate_factor() to make sure the new factor is valid.
validate_factor(new_factor(new_levels, levels))
}
base::factor
new_factor <- function(x = integer(), levels = character()) {
stopifnot(is.integer(x))
stopifnot(is.character(levels))
structure(
x,
levels = levels,
class = "factor"
)
}
## reset contrasts to defaults, sets the default contrasts to be used for all factors.
options(contrasts = c("contr.treatment", "contr.poly"))
## creates a new factor tens, which is a polynomial contrast of the factor tension.
tens <- with(warpbreaks, C(tension, poly, 1))
## shows the attributes of the new factor tens.
attributes(tens)
## tension SHOULD be an ordered factor, but as it is not we can use
## shows the use of the new factor tens in an ANOVA.
aov(breaks ~ wool + tens + tension, data = warpbreaks)
## show the use of ...  The default contrast is contr.treatment here
summary(lm(breaks ~ wool + C(tension, base = 2), data = warpbreaks))
# following on from help(esoph)
model3 <- glm(cbind(ncases, ncontrols) ~ agegp + C(tobgp, , 1) +
C(alcgp, , 1), data = esoph, family = binomial())
summary(model3)
updated_new_factor <- function(x = integer(), levels = character(), contrasts = NULL) {
# checks that x is an integer vector.
stopifnot(is.integer(x))
# checks that levels is a character vector.
stopifnot(is.character(levels))
# checks that contrasts is a numeric matrix.
if (!is.null(contrasts)) {
stopifnot(is.matrix(contrasts) && is.numeric(contrasts))
}
# returns a factor with the given levels and contrasts.
structure(
x,
levels = levels,
class = "factor",
contrasts = contrasts
)
}
utils::as.roman
new_roman <- function(x = integer()) {
# checking that x is an integer.
stopifnot(is.integer(x))
# creating a new object of class "roman" with the value of x.
structure(x, class = "roman")
}
validate_roman <- function(x) {
# unclasses x, which is a Roman object, and stores the result in values.
values <- unclass(x)
# checks whether any of the values are less than 1 or greater than 3899.
# If so, it stops with an error message.
if (any(values < 1 | values > 3899)) {
stop(
"Roman numbers must fall between 1 and 3899.",
call. = FALSE
)
}
# returns x.
x
}
roman_helper <- function(x = integer()) {
# converting the argument to an integer.
x <- as.integer(x)
# passing the integer to the new_roman function.
# passing the result of the new_roman function to the validate_roman function.
# returning the result of the validate_roman function.
validate_roman(new_roman(x))
}
validate_factor(new_factor(1:5, "a"))
validate_factor(new_factor(1:5, "a"))
new_factor(1:5, "a")
validate_factor(new_factor(1:5, "a"))
new_factor(1:2, "a", "b")
new_factor(1:2, c("a", "b"))
new_factor(1:5, "a")
factor <- function(x = character(), levels = unique(x)) {
ind <- match(x, levels)
validate_factor(new_factor(ind, levels))
}
# The levels argument is optional.
# If it's not provided, the function will use the unique values of x as the levels.
factor2 <- function(x = character(), levels = unique(x)) {
# uses match() to create a new factor with the same levels as x,
# but with the values in the order of the levels argument.
new_levels <- match(x, levels)
# Error if levels don't include all values
# uses setdiff() to find any values in x that are not in the levels argument.
missing <- unique(setdiff(x, levels))
# If there are any missing values, the function stops with an error message.
if (length(missing) > 0) {
stop(
"The following values are missing in the levels of x: ",
paste0("'", missing, "'", collapse = ", "), ".",
call. = FALSE
)
}
# uses validate_factor() to make sure the new factor is valid.
validate_factor(new_factor(new_levels, levels))
}
# Test
factor2(c("a", "b", "c", "d"), levels = c("a", "b"))
# The levels argument is optional.
# If it's not provided, the function will use the unique values of x as the levels.
factor2 <- function(x = character(), levels = unique(x)) {
# Error if levels don't include all values
# uses setdiff() to find any values in x that are not in the levels argument.
missing <- unique(setdiff(x, levels))
# If there are any missing values, the function stops with an error message.
if (length(missing) > 0) {
stop(
"The following values are missing in the levels of x: ",
paste0("'", missing, "'", collapse = ", "), ".",
call. = FALSE
)
}
# uses match() to create a new factor with the same levels as x,
# but with the values in the order of the levels argument.
new_levels <- match(x, levels)
# uses validate_factor() to make sure the new factor is valid.
validate_factor(new_factor(new_levels, levels))
}
# Test
factor2(c("a", "b", "c", "d"), levels = c("a", "b"))
S <- cards()
if(!require('prob')) {
install.packages('prob')
library('prob')
}
A <- c("a", "b", "c", "d")
B <- c("a", "b")
setdiff(B, A)
A <- c("a", "b", "c", "d")
B <- c("a", "b")
setdiff(B, A)
setdiff(A, B)
A <- c("a", "b", "c", "d")
B <- c("a", "b")
setdiff(A, B)
match(A,B)
# Test
new_factor(c("a", "b", "c", "d"), levels = c("a", "b"))
validate_factor(new_factor(c("a", "b", "c", "d"), levels = c("a", "b"))
validate_factor(new_factor(c("a", "b", "c", "d"), levels = c("a", "b"))
# The levels argument is optional.
# If it's not provided, the function will use the unique values of x as the levels.
factor2 <- function(x = character(), levels = unique(x)) {
# Error if levels don't include all values
# uses setdiff() to find any values in x that are not in the levels argument.
missing <- unique(setdiff(x, levels))
# If there are any missing values, the function stops with an error message.
if (length(missing) > 0) {
stop(
"The following values are missing in the levels of x: ",
paste0("'", missing, "'", collapse = ", "), ".",
call. = FALSE
)
}
# uses match() to create a new factor with the same levels as x,
# but with the values in the order of the levels argument.
ind <- match(x, levels)
# uses validate_factor() to make sure the new factor is valid.
validate_factor(new_factor(ind , levels))
}
# Test
factor2(c("a", "b", "c", "d"), levels = c("a", "b"))
