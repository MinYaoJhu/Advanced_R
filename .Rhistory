install.packages
# Some base R functions with point.separated names
install.packages
read.csv
list.files
download.file
data.frame
as.character
Sys.Date
all.equal
do.call
on.exit
ftype(mean)
class(some_days)
class(unclass(some_days))
x <- ecdf(rpois(100, 10))
x
class(x)
typeof(x)
typeof(x)
attributes(x)
x <- table(rpois(100, 5))
x
class(x)
typeof(x)
attributes(x)
attributes(x)
x <- ecdf(rpois(100, 10))
x
class(x)
typeof(x)
attributes(x)
new_Date <- function(x = double()) {
stopifnot(is.double(x))
structure(x, class = "Date")
}
new_Date(c(-1, 0, 1))
new_difftime <- function(x = double(), units = "secs") {
stopifnot(is.double(x))
units <- match.arg(units, c("secs", "mins", "hours", "days", "weeks"))
structure(x,
class = "difftime",
units = units
)
}
new_difftime(c(1, 10, 3600), "secs")
new_difftime(52, "weeks")
new_factor <- function(x = integer(), levels = character()) {
stopifnot(is.integer(x))
stopifnot(is.character(levels))
structure(
x,
levels = levels,
class = "factor"
)
}
new_factor(1:5, "a")
new_factor(0:1, "a")
validate_factor <- function(x) {
values <- unclass(x)
levels <- attr(x, "levels")
if (!all(!is.na(values) & values > 0)) {
stop(
"All `x` values must be non-missing and greater than zero",
call. = FALSE
)
}
if (length(levels) < max(values)) {
stop(
"There must be at least as many `levels` as possible values in `x`",
call. = FALSE
)
}
x
}
validate_factor(new_factor(1:5, "a"))
validate_factor(new_factor(0:1, "a"))
typeof(data.frame)
attributes(data.frame)
class(data.frame)
typeof(data.frame)
attributes(data.frame)
class(data.frame)
typeof(funs_df_name)
typeof(funs_df_filtered)
attributes(funs_df_filtered)
class(funs_df_filtered)
typeof(funs_df_filtered)
attributes(funs_df_filtered)
class(funs_df_filtered)
# Test
x <- list(a = 1, b = 2)
x
new_data.frame(x, n = 1)
new_data.frame <- function(x, n, row.names = NULL) {
# Check if the underlying object is a list
stopifnot(is.list(x))
# Check all inputs are the same length (This check also allows that x has length 0)
stopifnot(all(lengths(x) == n))
if (is.null(row.names)) {
# Use special row names helper from base R
row.names <- .set_row_names(n)
# .set_row_names(n) generates that form for automatic row names of length n, to be assigned to attr(<a data frame>, "row.names").
} else {
# Otherwise check that they're a character vector with the correct length
stopifnot(is.character(row.names), length(row.names) == n)
}
structure(
x,
class = "data.frame",
row.names = row.names
)
}
new_data.frame(x, n = 1)
#>   a b
#> 1 1 2
new_data.frame(x, n = 1, row.names = "l1")
# Test
x <- list(a = 1, b = 2)
x
new_data.frame(x, n = 1)
new_data.frame(x, n = 1, row.names = "l1")
# Create a data frame with 0 columns and 2 rows
new_data.frame(list(), n = 2)
#> data frame with 0 columns and 2 rows
factor
factor(c("a", "b", "c"), levels = c("a", "b"))
base::factor(c("a", "b", "c"), levels = c("a", "b"))
factor2 <- function(x, levels = unique(x)) {
new_levels <- match(x, levels)
# Error if levels don't include all values
missing <- unique(setdiff(x, levels))
if (length(missing) > 0) {
stop(
"The following values do not occur in the levels of x: ",
paste0("'", missing, "'", collapse = ", "), ".",
call. = FALSE
)
}
validate_factor(new_factor(new_levels, levels))
}
# Test
factor2(c("a", "b", "c"), levels = c("a", "b"))
# Test
factor2(c("a", "b", "c", "d"), levels = c("a", "b"))
base::factor
View(base::factor)
base::factor
## reset contrasts to defaults
options(contrasts = c("contr.treatment", "contr.poly"))
tens <- with(warpbreaks, C(tension, poly, 1))
attributes(tens)
## tension SHOULD be an ordered factor, but as it is not we can use
aov(breaks ~ wool + tens + tension, data = warpbreaks)
## show the use of ...  The default contrast is contr.treatment here
summary(lm(breaks ~ wool + C(tension, base = 2), data = warpbreaks))
# following on from help(esoph)
model3 <- glm(cbind(ncases, ncontrols) ~ agegp + C(tobgp, , 1) +
C(alcgp, , 1), data = esoph, family = binomial())
utils::as.roman
utils::as.roman
roman_helper <- function(x = integer()) {
x <- as.integer(x)
validate_roman(new_roman(x))
}
# Test
roman(c(1, 123, 3899, 14000))
new_roman <- function(x = integer()) {
# checking that x is an integer.
stopifnot(is.integer(x))
# creating a new object of class "roman" with the value of x.
structure(x, class = "roman")
}
validate_roman <- function(x) {
# unclasses x, which is a Roman object, and stores the result in values.
values <- unclass(x)
# checks whether any of the values are less than 1 or greater than 3899.
# If so, it stops with an error message.
if (any(values < 1 | values > 3899)) {
stop(
"Roman numbers must fall between 1 and 3899.",
call. = FALSE
)
}
# returns x.
x
}
roman_helper <- function(x = integer()) {
# converting the argument to an integer.
x <- as.integer(x)
# passing the integer to the new_roman function.
# passing the result of the new_roman function to the validate_roman function.
# returning the result of the validate_roman function.
validate_roman(new_roman(x))
}
# Test
roman(c(1, 123, 3899, 14000))
# Test
roman_helper(c(1, 123, 3899, 14000))
# Test
roman_helper(c(1, 123, 3899))
roman_helper(14000)
roman_helper(0)
library(rlang)
f <- function(x) {
g(x = 2)
}
g <- function(x) {
h(x = 3)
}
h <- function(x) {
stop()
}
f(x = 1)
library(rlang)
knitr::include_graphics("diagrams/environments/search-path.png")
library(rlang)
search()
search_envs()
knitr::include_graphics("diagrams/environments/search-path-2.png")
y <- 1
f <- function(x) x + y
fn_env(f)
knitr::include_graphics("diagrams/environments/binding.png")
e <- env()
e$g <- function() 1
knitr::include_graphics("diagrams/environments/binding-2.png")
sd
knitr::include_graphics("diagrams/environments/namespace-bind.png")
knitr::include_graphics("diagrams/environments/namespace-env.png")
knitr::include_graphics("diagrams/environments/namespace.png")
g <- function(x) {
if (!env_has(current_env(), "a")) {
message("Defining a")
a <- 1
} else {
a <- a + 1
}
a
}
g(10)
g(10)
h <- function(x) {
# 1.
a <- 2 # 2.
x + a
}
y <- h(1) # 3.
knitr::include_graphics("diagrams/environments/execution.png")
h2 <- function(x) {
a <- x * 2
current_env()
}
e <- h2(x = 10)
env_print(e)
fn_env(h2)
plus <- function(x) {
function(y) x + y
}
plus_one <- plus(1)
plus_one
knitr::include_graphics("diagrams/environments/closure.png")
plus_one(2)
knitr::include_graphics("diagrams/environments/closure-call.png")
search_envs()
env_parents(global_env())
f1 <- function(x1) {
f2 <- function(x2) {
f3 <- function(x3) {
x1 + x2 + x3
}
f3(3)
env_print()
}
f2(2)
env_print()
}
f1(1)
env_print()
knitr::include_graphics("diagrams/environments/Advanced_R_7.4.5_Exercises.png")
#?str
fget <- function(name, env = caller_env()) {
# Base case
if (identical(env, emptyenv())) {
stop("Could not find a function called ", name, ".", call. = FALSE)
}
# Success case
else{
if (env_has(env, name)) {
obj <- env_get(env, name)
if (is.function(obj)) {
return(list(fun = obj, env = env))
}
}
}
# Recursive anyway
fget(name, env_parent(env))
}
fstr <- function(fun_name, env = caller_env()) {
if (!is.character(fun_name)) {
stop("`fun_name` should be a string.", call. = FALSE)
}
fun_env <- fget(fun_name, env)
list(
environment = fun_env$env,
namespace = fn_env(fun_env$fun)
)
}
# Test
fstr("mean")
fstr("str")
f <- function(x) {
g(x = 2)
}
g <- function(x) {
h(x = 3)
}
h <- function(x) {
stop()
}
knitr::include_graphics("diagrams/environments/calling.png")
ls
ls()
env_names(current_env())
new_ls <- function(env = caller_env()) {
sort(env_names(env))
}
ls(all.names = TRUE)
new_ls()
#test
ls(e)
new_ls(e)
my_env <- new.env(parent = emptyenv())
my_env$a <- 1
get_a <- function() {
my_env$a
}
set_a <- function(value) {
old <- my_env$a
my_env$a <- value
invisible(old)
}
library(rlang)
knitr::include_graphics("diagrams/environments/search-path.png")
library(rlang)
search()
search_envs()
knitr::include_graphics("diagrams/environments/search-path-2.png")
y <- 1
f <- function(x) x + y
fn_env(f)
knitr::include_graphics("diagrams/environments/binding.png")
e <- env()
e$g <- function() 1
knitr::include_graphics("diagrams/environments/binding-2.png")
sd
knitr::include_graphics("diagrams/environments/namespace-bind.png")
knitr::include_graphics("diagrams/environments/namespace-env.png")
knitr::include_graphics("diagrams/environments/namespace.png")
g <- function(x) {
if (!env_has(current_env(), "a")) {
message("Defining a")
a <- 1
} else {
a <- a + 1
}
a
}
g(10)
g(10)
h <- function(x) {
# 1.
a <- 2 # 2.
x + a
}
y <- h(1) # 3.
knitr::include_graphics("diagrams/environments/execution.png")
h2 <- function(x) {
a <- x * 2
current_env()
}
e <- h2(x = 10)
env_print(e)
fn_env(h2)
plus <- function(x) {
function(y) x + y
}
plus_one <- plus(1)
plus_one
knitr::include_graphics("diagrams/environments/closure.png")
plus_one(2)
knitr::include_graphics("diagrams/environments/closure-call.png")
search_envs()
env_parents(global_env())
f1 <- function(x1) {
f2 <- function(x2) {
f3 <- function(x3) {
x1 + x2 + x3
}
f3(3)
env_print()
}
f2(2)
env_print()
}
f1(1)
env_print()
knitr::include_graphics("diagrams/environments/Advanced_R_7.4.5_Exercises.png")
#?str
fget <- function(name, env = caller_env()) {
# Base case
if (identical(env, emptyenv())) {
stop("Could not find a function called ", name, ".", call. = FALSE)
}
# Success case
else{
if (env_has(env, name)) {
obj <- env_get(env, name)
if (is.function(obj)) {
return(list(fun = obj, env = env))
}
}
}
# Recursive anyway
fget(name, env_parent(env))
}
fstr <- function(fun_name, env = caller_env()) {
if (!is.character(fun_name)) {
stop("`fun_name` should be a string.", call. = FALSE)
}
fun_env <- fget(fun_name, env)
list(
environment = fun_env$env,
namespace = fn_env(fun_env$fun)
)
}
# Test
fstr("mean")
fstr("str")
f <- function(x) {
g(x = 2)
}
g <- function(x) {
h(x = 3)
}
h <- function(x) {
stop()
}
knitr::include_graphics("diagrams/environments/calling.png")
ls
ls()
env_names(current_env())
new_ls <- function(env = caller_env()) {
sort(env_names(env))
}
ls(all.names = TRUE)
new_ls()
#test
ls(e)
new_ls(e)
my_env <- new.env(parent = emptyenv())
my_env$a <- 1
get_a <- function() {
my_env$a
}
set_a <- function(value) {
old <- my_env$a
my_env$a <- value
invisible(old)
}
View(ls)
new_ls <- function(env = caller_env()) {
sort(env_names(env))
}
ls(all.names = TRUE)
new_ls()
#test
ls(e)
new_ls(e)
View(f)
f <- function(x) {
g(x = 2)
}
g <- function(x) {
h(x = 3)
}
h <- function(x) {
stop()
}
# f calls g, which calls h, which calls stop.
f <- function(x) {
g(x = 2)
}
g <- function(x) {
h(x = 3)
}
h <- function(x) {
stop()
}
f(x = 1)
#> Error:
traceback()
h <- function(x) {
lobstr::cst()
}
f(x = 1)
#> █
#> └─f(x = 1)
#>   └─g(x = 2)
#>     └─h(x = 3)
#>       └─lobstr::cst()
f
